{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/old.jpg","path":"css/images/old.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1531278524070},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1531278524090},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1531278524074},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1531278524074},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1531278524090},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1531278524074},{"_id":"source/_posts/Android_7.1.2_boot_anim.md","hash":"a89e7ddfcd815b4f65bd7dcfad55620d74ca8084","modified":1532170017902},{"_id":"source/_posts/Android_DispatchMotionEvent.md","hash":"28b84f9ee83b0e744c38ff0c58b97a89c42ed10f","modified":1533206059674},{"_id":"source/_posts/Android_DispatchMotionEvent2.md","hash":"80adff5f2308bcc77ab5568ed49c5367201fa716","modified":1533343826837},{"_id":"source/_posts/Framework_jni_1.md","hash":"dc7f577b4fd9e50b7c195f5abb984c7974269bea","modified":1535947080141},{"_id":"source/_posts/Framework_jni_1.md~","hash":"a5edebd34f023c026d5f9b27d81f6b85c7785aca","modified":1535946846985},{"_id":"source/_posts/Ubuntu_14.04_Android_7.1.2_env_config.md","hash":"ad27e030ed0816b7cfb179a64e0791dcbc626d9d","modified":1531796074490},{"_id":"source/_posts/java8.md","hash":"48ff4384b074714576972073eace206638c6d7bf","modified":1531385528423},{"_id":"source/_posts/linearLayout.md","hash":"4fdc0de2c85f2b632e5f8a1bfc2331c8b995c0bf","modified":1531386086975},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1531278524082},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1531278524082},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1531278524082},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1531278524090},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1531278524086},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1531278524090},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1531278524090},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1531278524090},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1531278524090},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1531278524090},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1531278524090},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531278524094},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531278524094},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1531278524094},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1531278524094},{"_id":"source/_posts/linearLayout/width_0.png","hash":"3221739045158b7be2f8735098e96725a5aea446","modified":1531378131679},{"_id":"source/_posts/linearLayout/width_enough.png","hash":"c65508db31597246b60ad0ce1a09f278d17e7fbf","modified":1531378227715},{"_id":"source/_posts/linearLayout/width_less.png","hash":"10325733e5457694c162feaedc20fb585975433c","modified":1531378253219},{"_id":"source/_posts/linearLayout/width_match.png","hash":"7bacd4abac7a1d921c92c9915dbd516041c91fc5","modified":1531378194643},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1531278524098},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1531278524114},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1531278524106},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"dc7fa788b02dc9c71c434efbddfc0662bf9ea565","modified":1531302084182},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1531278524106},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1531278524106},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1531278524114},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1531278524114},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1531278524114},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1531278524114},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1531278524106},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1531278524106},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1531278524106},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1531278524106},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1531278524106},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1531278524114},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1531278524122},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1531278524118},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1531278524126},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1531278524150},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1531278524134},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1531278524130},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1531278524130},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1531278524174},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1531278524142},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1531278524142},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1531278524142},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1531278524138},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1531278524150},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1531278524162},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1531278524162},{"_id":"themes/landscape/layout/_partial/post/livere.ejs","hash":"3b87026e7a952bf07448022b2e0fad76ddd3b7d7","modified":1531297710327},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1531278524162},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1531278524162},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1531278524162},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1531278524150},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1531278524162},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1531278524182},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1531278524182},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1531278524182},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1531278524182},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1531278524186},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1531278524186},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1531278524186},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1531278524186},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1531278524154},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1531278524186},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1531278524150},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1531278524198},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1531278524186},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1531278524194},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1531278524194},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1531278524198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1531278524198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1531278524198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1531278524198},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1531278524186},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"861107afc034c595b1b7618717af3e73b3c9c165","modified":1531296767799},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1531278524194},{"_id":"themes/landscape/source/css/images/old.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1531278524150},{"_id":"public/2018/08/04/Android_DispatchMotionEvent2/index.html","hash":"9b18446dcc5bc97d3d522d354daa9d150bfab595","modified":1535949736471},{"_id":"public/2018/07/21/Android_7.1.2_boot_anim/index.html","hash":"3bc56dbae0a12a921ef075b501b28fe5b3fd0e14","modified":1535949736471},{"_id":"public/2018/07/12/linearLayout/index.html","hash":"3ddaea41b7dfe2e4cb9a8c00c949175b076ecd1e","modified":1535949736471},{"_id":"public/index.html","hash":"47a0c470354341fec3e12e1178cc65569db22b96","modified":1535949736471},{"_id":"public/archives/index.html","hash":"bd598ab2dda353bdd6ebdbd2548201b73c451909","modified":1535949736471},{"_id":"public/archives/2018/index.html","hash":"29e49692b492eb33bff6e3ada3d7db119ac1a032","modified":1535949736471},{"_id":"public/archives/2018/07/index.html","hash":"a57d39b408fcd4beddea4a4b230a2b460054a99b","modified":1535949736471},{"_id":"public/archives/2018/08/index.html","hash":"0954ee79f642e89d1eb8ad0dc469dd81c4d355ac","modified":1535949736472},{"_id":"public/archives/2018/09/index.html","hash":"f9155f1047eeb8c9400516087b032404c7f259ae","modified":1535949736472},{"_id":"public/2018/09/03/Framework_jni_1/index.html","hash":"03150cfd51cc6ab7fb76e1aec2fb122919792fb7","modified":1535949736472},{"_id":"public/2018/08/02/Android_DispatchMotionEvent/index.html","hash":"be4fe184805c239d9a2365f2021641a8a83d0abe","modified":1535949736472},{"_id":"public/2018/07/17/Ubuntu_14.04_Android_7.1.2_env_config/index.html","hash":"f3a8348ca4c67038b308dee7316b1e9629f13be2","modified":1535949736472},{"_id":"public/2018/07/12/java8/index.html","hash":"00bb1744c8af77130f3b66d7a4d1f92457bd81ab","modified":1535949736472},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535949736477},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535949736477},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535949736477},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535949736477},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535949736477},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535949736477},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1535949736477},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1535949736477},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535949736477},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1535949736477},{"_id":"public/2018/07/12/linearLayout/width_0.png","hash":"3221739045158b7be2f8735098e96725a5aea446","modified":1535949736477},{"_id":"public/2018/07/12/linearLayout/width_enough.png","hash":"c65508db31597246b60ad0ce1a09f278d17e7fbf","modified":1535949736477},{"_id":"public/2018/07/12/linearLayout/width_less.png","hash":"10325733e5457694c162feaedc20fb585975433c","modified":1535949736477},{"_id":"public/2018/07/12/linearLayout/width_match.png","hash":"7bacd4abac7a1d921c92c9915dbd516041c91fc5","modified":1535949736477},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1535949736743},{"_id":"public/css/images/banner.jpg","hash":"861107afc034c595b1b7618717af3e73b3c9c165","modified":1535949736744},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1535949736746},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1535949736746},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1535949736746},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1535949736746},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1535949736746},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1535949736746},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1535949736746},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1535949736746},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1535949736748},{"_id":"public/css/images/old.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1535949736748},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1535949736749},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1535949736752}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Android 7.1.2源码之修改开机动画","_content":"\n&emsp;&emsp;开机动画是Android系统的UI启动过程中的动画显示，在UI启动完成，看到桌面或者锁屏界面出现后，自动结束。对开机动画的定制比较简单，制作图片就可以完成。开机动画执行者代码路径为：frameworks/base/cmds/bootanimation。它将生成本地程序bootanimation，被init通过init.rc启动。\n<!-- more -->\n**开机动画的两种内容：**\n1. zip包。\n    /system/media/bootanimation-encrypted.zip\n    /system/media/bootanimation.zip\n    /oem/media/bootanimation.zip\n以上任意一种，放置OK后，重新make生成img。\n2. 默认动画。\n默认动画是资源包中的资产文件，路径为：frameworks/base/core/res/assets/images。默认动画的两个文件为android-logo-mask.png和andriod-logo-shine.png。\n默认动画的运行逻辑是：有透明区域mask文件放在上面，shine文件放在下面水平方向移动。这两个文件可以被替换实现定制。\n优先使用的是特定格式的zip包，如果不能成功，则使用默认的动画。至于bootanimation.zip里边的格式，很多书或者帖子都有讲，感觉不是很全，下面贴上源码中的格式。\n\n# bootanimation format\n\n## zipfile paths\n\nThe system selects a boot animation zipfile from the following locations, in order:\n\n    /system/media/bootanimation-encrypted.zip (if getprop(\"vold.decrypt\") = '1')\n    /system/media/bootanimation.zip\n    /oem/media/bootanimation.zip\n\n## zipfile layout\n\nThe `bootanimation.zip` archive file includes:\n\n    desc.txt - a text file\n    part0  \\\n    part1   \\  directories full of PNG frames\n    ...     /\n    partN  /\n\n## desc.txt format\n\nThe first line defines the general parameters of the animation:\n\n    WIDTH HEIGHT FPS\n\n  * **WIDTH:** animation width (pixels)\n  * **HEIGHT:** animation height (pixels)\n  * **FPS:** frames per second, e.g. 60\n\nIt is followed by a number of rows of the form:\n\n    TYPE COUNT PAUSE PATH [#RGBHEX CLOCK]\n\n  * **TYPE:** a single char indicating what type of animation segment this is:\n      + `p` -- this part will play unless interrupted by the end of the boot\n      + `c` -- this part will play to completion, no matter what\n  * **COUNT:** how many times to play the animation, or 0 to loop forever until boot is complete\n  * **PAUSE:** number of FRAMES to delay after this part ends\n  * **PATH:** directory in which to find the frames for this part (e.g. `part0`)\n  * **RGBHEX:** _(OPTIONAL)_ a background color, specified as `#RRGGBB`\n  * **CLOCK:** _(OPTIONAL)_ the y-coordinate at which to draw the current time (for watches)\n\nThere is also a special TYPE, `$SYSTEM`, that loads `/system/media/bootanimation.zip`\nand plays that.\n\n## loading and playing frames\n\nEach part is scanned and loaded directly from the zip archive. Within a part directory, every file\n(except `trim.txt` and `audio.wav`; see next sections) is expected to be a PNG file that represents\none frame in that part (at the specified resolution). For this reason it is important that frames be\nnamed sequentially (e.g. `part000.png`, `part001.png`, ...) and added to the zip archive in that\norder.\n\n## trim.txt\n\nTo save on memory, textures may be trimmed by their background color.  trim.txt sequentially lists\nthe trim output for each frame in its directory, so the frames may be properly positioned.\nOutput should be of the form: `WxH+X+Y`. Example:\n\n    713x165+388+914\n    708x152+388+912\n    707x139+388+911\n    649x92+388+910\n\nIf the file is not present, each frame is assumed to be the same size as the animation.\n\n## audio.wav\n\nEach part may optionally play a `wav` sample when it starts. To enable this, add a file\nwith the name `audio.wav` in the part directory.\n\n## exiting\n\nThe system will end the boot animation (first completing any incomplete or even entirely unplayed\nparts that are of type `c`) when the system is finished booting. (This is accomplished by setting\nthe system property `service.bootanim.exit` to a nonzero string.)\n\n## protips\n\n### PNG compression\n\nUse `zopflipng` if you have it, otherwise `pngcrush` will do. e.g.:\n\n    for fn in *.png ; do\n        zopflipng -m ${fn}s ${fn}s.new && mv -f ${fn}s.new ${fn}\n        # or: pngcrush -q ....\n    done\n\nSome animations benefit from being reduced to 256 colors:\n\n    pngquant --force --ext .png *.png\n    # alternatively: mogrify -colors 256 anim-tmp/*/*.png\n\n### creating the ZIP archive\n\n    cd <path-to-pieces>\n    zip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part*\n\nNote that the ZIP archive is not actually compressed! The PNG files are already as compressed\nas they can reasonably get, and there is unlikely to be any redundancy between files.\n\n\n\n\n\n\n","source":"_posts/Android_7.1.2_boot_anim.md","raw":"---\ntitle: Android 7.1.2源码之修改开机动画\n---\n\n&emsp;&emsp;开机动画是Android系统的UI启动过程中的动画显示，在UI启动完成，看到桌面或者锁屏界面出现后，自动结束。对开机动画的定制比较简单，制作图片就可以完成。开机动画执行者代码路径为：frameworks/base/cmds/bootanimation。它将生成本地程序bootanimation，被init通过init.rc启动。\n<!-- more -->\n**开机动画的两种内容：**\n1. zip包。\n    /system/media/bootanimation-encrypted.zip\n    /system/media/bootanimation.zip\n    /oem/media/bootanimation.zip\n以上任意一种，放置OK后，重新make生成img。\n2. 默认动画。\n默认动画是资源包中的资产文件，路径为：frameworks/base/core/res/assets/images。默认动画的两个文件为android-logo-mask.png和andriod-logo-shine.png。\n默认动画的运行逻辑是：有透明区域mask文件放在上面，shine文件放在下面水平方向移动。这两个文件可以被替换实现定制。\n优先使用的是特定格式的zip包，如果不能成功，则使用默认的动画。至于bootanimation.zip里边的格式，很多书或者帖子都有讲，感觉不是很全，下面贴上源码中的格式。\n\n# bootanimation format\n\n## zipfile paths\n\nThe system selects a boot animation zipfile from the following locations, in order:\n\n    /system/media/bootanimation-encrypted.zip (if getprop(\"vold.decrypt\") = '1')\n    /system/media/bootanimation.zip\n    /oem/media/bootanimation.zip\n\n## zipfile layout\n\nThe `bootanimation.zip` archive file includes:\n\n    desc.txt - a text file\n    part0  \\\n    part1   \\  directories full of PNG frames\n    ...     /\n    partN  /\n\n## desc.txt format\n\nThe first line defines the general parameters of the animation:\n\n    WIDTH HEIGHT FPS\n\n  * **WIDTH:** animation width (pixels)\n  * **HEIGHT:** animation height (pixels)\n  * **FPS:** frames per second, e.g. 60\n\nIt is followed by a number of rows of the form:\n\n    TYPE COUNT PAUSE PATH [#RGBHEX CLOCK]\n\n  * **TYPE:** a single char indicating what type of animation segment this is:\n      + `p` -- this part will play unless interrupted by the end of the boot\n      + `c` -- this part will play to completion, no matter what\n  * **COUNT:** how many times to play the animation, or 0 to loop forever until boot is complete\n  * **PAUSE:** number of FRAMES to delay after this part ends\n  * **PATH:** directory in which to find the frames for this part (e.g. `part0`)\n  * **RGBHEX:** _(OPTIONAL)_ a background color, specified as `#RRGGBB`\n  * **CLOCK:** _(OPTIONAL)_ the y-coordinate at which to draw the current time (for watches)\n\nThere is also a special TYPE, `$SYSTEM`, that loads `/system/media/bootanimation.zip`\nand plays that.\n\n## loading and playing frames\n\nEach part is scanned and loaded directly from the zip archive. Within a part directory, every file\n(except `trim.txt` and `audio.wav`; see next sections) is expected to be a PNG file that represents\none frame in that part (at the specified resolution). For this reason it is important that frames be\nnamed sequentially (e.g. `part000.png`, `part001.png`, ...) and added to the zip archive in that\norder.\n\n## trim.txt\n\nTo save on memory, textures may be trimmed by their background color.  trim.txt sequentially lists\nthe trim output for each frame in its directory, so the frames may be properly positioned.\nOutput should be of the form: `WxH+X+Y`. Example:\n\n    713x165+388+914\n    708x152+388+912\n    707x139+388+911\n    649x92+388+910\n\nIf the file is not present, each frame is assumed to be the same size as the animation.\n\n## audio.wav\n\nEach part may optionally play a `wav` sample when it starts. To enable this, add a file\nwith the name `audio.wav` in the part directory.\n\n## exiting\n\nThe system will end the boot animation (first completing any incomplete or even entirely unplayed\nparts that are of type `c`) when the system is finished booting. (This is accomplished by setting\nthe system property `service.bootanim.exit` to a nonzero string.)\n\n## protips\n\n### PNG compression\n\nUse `zopflipng` if you have it, otherwise `pngcrush` will do. e.g.:\n\n    for fn in *.png ; do\n        zopflipng -m ${fn}s ${fn}s.new && mv -f ${fn}s.new ${fn}\n        # or: pngcrush -q ....\n    done\n\nSome animations benefit from being reduced to 256 colors:\n\n    pngquant --force --ext .png *.png\n    # alternatively: mogrify -colors 256 anim-tmp/*/*.png\n\n### creating the ZIP archive\n\n    cd <path-to-pieces>\n    zip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part*\n\nNote that the ZIP archive is not actually compressed! The PNG files are already as compressed\nas they can reasonably get, and there is unlikely to be any redundancy between files.\n\n\n\n\n\n\n","slug":"Android_7.1.2_boot_anim","published":1,"date":"2018-07-21T10:46:57.938Z","updated":"2018-07-21T10:46:57.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdas0000idfs1awr6tmw","content":"<p>&emsp;&emsp;开机动画是Android系统的UI启动过程中的动画显示，在UI启动完成，看到桌面或者锁屏界面出现后，自动结束。对开机动画的定制比较简单，制作图片就可以完成。开机动画执行者代码路径为：frameworks/base/cmds/bootanimation。它将生成本地程序bootanimation，被init通过init.rc启动。<br><a id=\"more\"></a><br><strong>开机动画的两种内容：</strong></p>\n<ol>\n<li>zip包。<br> /system/media/bootanimation-encrypted.zip<br> /system/media/bootanimation.zip<br> /oem/media/bootanimation.zip<br>以上任意一种，放置OK后，重新make生成img。</li>\n<li>默认动画。<br>默认动画是资源包中的资产文件，路径为：frameworks/base/core/res/assets/images。默认动画的两个文件为android-logo-mask.png和andriod-logo-shine.png。<br>默认动画的运行逻辑是：有透明区域mask文件放在上面，shine文件放在下面水平方向移动。这两个文件可以被替换实现定制。<br>优先使用的是特定格式的zip包，如果不能成功，则使用默认的动画。至于bootanimation.zip里边的格式，很多书或者帖子都有讲，感觉不是很全，下面贴上源码中的格式。</li>\n</ol>\n<h1 id=\"bootanimation-format\"><a href=\"#bootanimation-format\" class=\"headerlink\" title=\"bootanimation format\"></a>bootanimation format</h1><h2 id=\"zipfile-paths\"><a href=\"#zipfile-paths\" class=\"headerlink\" title=\"zipfile paths\"></a>zipfile paths</h2><p>The system selects a boot animation zipfile from the following locations, in order:</p>\n<pre><code>/system/media/bootanimation-encrypted.zip (if getprop(&quot;vold.decrypt&quot;) = &apos;1&apos;)\n/system/media/bootanimation.zip\n/oem/media/bootanimation.zip\n</code></pre><h2 id=\"zipfile-layout\"><a href=\"#zipfile-layout\" class=\"headerlink\" title=\"zipfile layout\"></a>zipfile layout</h2><p>The <code>bootanimation.zip</code> archive file includes:</p>\n<pre><code>desc.txt - a text file\npart0  \\\npart1   \\  directories full of PNG frames\n...     /\npartN  /\n</code></pre><h2 id=\"desc-txt-format\"><a href=\"#desc-txt-format\" class=\"headerlink\" title=\"desc.txt format\"></a>desc.txt format</h2><p>The first line defines the general parameters of the animation:</p>\n<pre><code>WIDTH HEIGHT FPS\n</code></pre><ul>\n<li><strong>WIDTH:</strong> animation width (pixels)</li>\n<li><strong>HEIGHT:</strong> animation height (pixels)</li>\n<li><strong>FPS:</strong> frames per second, e.g. 60</li>\n</ul>\n<p>It is followed by a number of rows of the form:</p>\n<pre><code>TYPE COUNT PAUSE PATH [#RGBHEX CLOCK]\n</code></pre><ul>\n<li><strong>TYPE:</strong> a single char indicating what type of animation segment this is:<ul>\n<li><code>p</code> – this part will play unless interrupted by the end of the boot</li>\n<li><code>c</code> – this part will play to completion, no matter what</li>\n</ul>\n</li>\n<li><strong>COUNT:</strong> how many times to play the animation, or 0 to loop forever until boot is complete</li>\n<li><strong>PAUSE:</strong> number of FRAMES to delay after this part ends</li>\n<li><strong>PATH:</strong> directory in which to find the frames for this part (e.g. <code>part0</code>)</li>\n<li><strong>RGBHEX:</strong> <em>(OPTIONAL)</em> a background color, specified as <code>#RRGGBB</code></li>\n<li><strong>CLOCK:</strong> <em>(OPTIONAL)</em> the y-coordinate at which to draw the current time (for watches)</li>\n</ul>\n<p>There is also a special TYPE, <code>$SYSTEM</code>, that loads <code>/system/media/bootanimation.zip</code><br>and plays that.</p>\n<h2 id=\"loading-and-playing-frames\"><a href=\"#loading-and-playing-frames\" class=\"headerlink\" title=\"loading and playing frames\"></a>loading and playing frames</h2><p>Each part is scanned and loaded directly from the zip archive. Within a part directory, every file<br>(except <code>trim.txt</code> and <code>audio.wav</code>; see next sections) is expected to be a PNG file that represents<br>one frame in that part (at the specified resolution). For this reason it is important that frames be<br>named sequentially (e.g. <code>part000.png</code>, <code>part001.png</code>, …) and added to the zip archive in that<br>order.</p>\n<h2 id=\"trim-txt\"><a href=\"#trim-txt\" class=\"headerlink\" title=\"trim.txt\"></a>trim.txt</h2><p>To save on memory, textures may be trimmed by their background color.  trim.txt sequentially lists<br>the trim output for each frame in its directory, so the frames may be properly positioned.<br>Output should be of the form: <code>WxH+X+Y</code>. Example:</p>\n<pre><code>713x165+388+914\n708x152+388+912\n707x139+388+911\n649x92+388+910\n</code></pre><p>If the file is not present, each frame is assumed to be the same size as the animation.</p>\n<h2 id=\"audio-wav\"><a href=\"#audio-wav\" class=\"headerlink\" title=\"audio.wav\"></a>audio.wav</h2><p>Each part may optionally play a <code>wav</code> sample when it starts. To enable this, add a file<br>with the name <code>audio.wav</code> in the part directory.</p>\n<h2 id=\"exiting\"><a href=\"#exiting\" class=\"headerlink\" title=\"exiting\"></a>exiting</h2><p>The system will end the boot animation (first completing any incomplete or even entirely unplayed<br>parts that are of type <code>c</code>) when the system is finished booting. (This is accomplished by setting<br>the system property <code>service.bootanim.exit</code> to a nonzero string.)</p>\n<h2 id=\"protips\"><a href=\"#protips\" class=\"headerlink\" title=\"protips\"></a>protips</h2><h3 id=\"PNG-compression\"><a href=\"#PNG-compression\" class=\"headerlink\" title=\"PNG compression\"></a>PNG compression</h3><p>Use <code>zopflipng</code> if you have it, otherwise <code>pngcrush</code> will do. e.g.:</p>\n<pre><code>for fn in *.png ; do\n    zopflipng -m ${fn}s ${fn}s.new &amp;&amp; mv -f ${fn}s.new ${fn}\n    # or: pngcrush -q ....\ndone\n</code></pre><p>Some animations benefit from being reduced to 256 colors:</p>\n<pre><code>pngquant --force --ext .png *.png\n# alternatively: mogrify -colors 256 anim-tmp/*/*.png\n</code></pre><h3 id=\"creating-the-ZIP-archive\"><a href=\"#creating-the-ZIP-archive\" class=\"headerlink\" title=\"creating the ZIP archive\"></a>creating the ZIP archive</h3><pre><code>cd &lt;path-to-pieces&gt;\nzip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part*\n</code></pre><p>Note that the ZIP archive is not actually compressed! The PNG files are already as compressed<br>as they can reasonably get, and there is unlikely to be any redundancy between files.</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;开机动画是Android系统的UI启动过程中的动画显示，在UI启动完成，看到桌面或者锁屏界面出现后，自动结束。对开机动画的定制比较简单，制作图片就可以完成。开机动画执行者代码路径为：frameworks/base/cmds/bootanimation。它将生成本地程序bootanimation，被init通过init.rc启动。<br></p>","more":"<br><strong>开机动画的两种内容：</strong><p></p>\n<ol>\n<li>zip包。<br> /system/media/bootanimation-encrypted.zip<br> /system/media/bootanimation.zip<br> /oem/media/bootanimation.zip<br>以上任意一种，放置OK后，重新make生成img。</li>\n<li>默认动画。<br>默认动画是资源包中的资产文件，路径为：frameworks/base/core/res/assets/images。默认动画的两个文件为android-logo-mask.png和andriod-logo-shine.png。<br>默认动画的运行逻辑是：有透明区域mask文件放在上面，shine文件放在下面水平方向移动。这两个文件可以被替换实现定制。<br>优先使用的是特定格式的zip包，如果不能成功，则使用默认的动画。至于bootanimation.zip里边的格式，很多书或者帖子都有讲，感觉不是很全，下面贴上源码中的格式。</li>\n</ol>\n<h1 id=\"bootanimation-format\"><a href=\"#bootanimation-format\" class=\"headerlink\" title=\"bootanimation format\"></a>bootanimation format</h1><h2 id=\"zipfile-paths\"><a href=\"#zipfile-paths\" class=\"headerlink\" title=\"zipfile paths\"></a>zipfile paths</h2><p>The system selects a boot animation zipfile from the following locations, in order:</p>\n<pre><code>/system/media/bootanimation-encrypted.zip (if getprop(&quot;vold.decrypt&quot;) = &apos;1&apos;)\n/system/media/bootanimation.zip\n/oem/media/bootanimation.zip\n</code></pre><h2 id=\"zipfile-layout\"><a href=\"#zipfile-layout\" class=\"headerlink\" title=\"zipfile layout\"></a>zipfile layout</h2><p>The <code>bootanimation.zip</code> archive file includes:</p>\n<pre><code>desc.txt - a text file\npart0  \\\npart1   \\  directories full of PNG frames\n...     /\npartN  /\n</code></pre><h2 id=\"desc-txt-format\"><a href=\"#desc-txt-format\" class=\"headerlink\" title=\"desc.txt format\"></a>desc.txt format</h2><p>The first line defines the general parameters of the animation:</p>\n<pre><code>WIDTH HEIGHT FPS\n</code></pre><ul>\n<li><strong>WIDTH:</strong> animation width (pixels)</li>\n<li><strong>HEIGHT:</strong> animation height (pixels)</li>\n<li><strong>FPS:</strong> frames per second, e.g. 60</li>\n</ul>\n<p>It is followed by a number of rows of the form:</p>\n<pre><code>TYPE COUNT PAUSE PATH [#RGBHEX CLOCK]\n</code></pre><ul>\n<li><strong>TYPE:</strong> a single char indicating what type of animation segment this is:<ul>\n<li><code>p</code> – this part will play unless interrupted by the end of the boot</li>\n<li><code>c</code> – this part will play to completion, no matter what</li>\n</ul>\n</li>\n<li><strong>COUNT:</strong> how many times to play the animation, or 0 to loop forever until boot is complete</li>\n<li><strong>PAUSE:</strong> number of FRAMES to delay after this part ends</li>\n<li><strong>PATH:</strong> directory in which to find the frames for this part (e.g. <code>part0</code>)</li>\n<li><strong>RGBHEX:</strong> <em>(OPTIONAL)</em> a background color, specified as <code>#RRGGBB</code></li>\n<li><strong>CLOCK:</strong> <em>(OPTIONAL)</em> the y-coordinate at which to draw the current time (for watches)</li>\n</ul>\n<p>There is also a special TYPE, <code>$SYSTEM</code>, that loads <code>/system/media/bootanimation.zip</code><br>and plays that.</p>\n<h2 id=\"loading-and-playing-frames\"><a href=\"#loading-and-playing-frames\" class=\"headerlink\" title=\"loading and playing frames\"></a>loading and playing frames</h2><p>Each part is scanned and loaded directly from the zip archive. Within a part directory, every file<br>(except <code>trim.txt</code> and <code>audio.wav</code>; see next sections) is expected to be a PNG file that represents<br>one frame in that part (at the specified resolution). For this reason it is important that frames be<br>named sequentially (e.g. <code>part000.png</code>, <code>part001.png</code>, …) and added to the zip archive in that<br>order.</p>\n<h2 id=\"trim-txt\"><a href=\"#trim-txt\" class=\"headerlink\" title=\"trim.txt\"></a>trim.txt</h2><p>To save on memory, textures may be trimmed by their background color.  trim.txt sequentially lists<br>the trim output for each frame in its directory, so the frames may be properly positioned.<br>Output should be of the form: <code>WxH+X+Y</code>. Example:</p>\n<pre><code>713x165+388+914\n708x152+388+912\n707x139+388+911\n649x92+388+910\n</code></pre><p>If the file is not present, each frame is assumed to be the same size as the animation.</p>\n<h2 id=\"audio-wav\"><a href=\"#audio-wav\" class=\"headerlink\" title=\"audio.wav\"></a>audio.wav</h2><p>Each part may optionally play a <code>wav</code> sample when it starts. To enable this, add a file<br>with the name <code>audio.wav</code> in the part directory.</p>\n<h2 id=\"exiting\"><a href=\"#exiting\" class=\"headerlink\" title=\"exiting\"></a>exiting</h2><p>The system will end the boot animation (first completing any incomplete or even entirely unplayed<br>parts that are of type <code>c</code>) when the system is finished booting. (This is accomplished by setting<br>the system property <code>service.bootanim.exit</code> to a nonzero string.)</p>\n<h2 id=\"protips\"><a href=\"#protips\" class=\"headerlink\" title=\"protips\"></a>protips</h2><h3 id=\"PNG-compression\"><a href=\"#PNG-compression\" class=\"headerlink\" title=\"PNG compression\"></a>PNG compression</h3><p>Use <code>zopflipng</code> if you have it, otherwise <code>pngcrush</code> will do. e.g.:</p>\n<pre><code>for fn in *.png ; do\n    zopflipng -m ${fn}s ${fn}s.new &amp;&amp; mv -f ${fn}s.new ${fn}\n    # or: pngcrush -q ....\ndone\n</code></pre><p>Some animations benefit from being reduced to 256 colors:</p>\n<pre><code>pngquant --force --ext .png *.png\n# alternatively: mogrify -colors 256 anim-tmp/*/*.png\n</code></pre><h3 id=\"creating-the-ZIP-archive\"><a href=\"#creating-the-ZIP-archive\" class=\"headerlink\" title=\"creating the ZIP archive\"></a>creating the ZIP archive</h3><pre><code>cd &lt;path-to-pieces&gt;\nzip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part*\n</code></pre><p>Note that the ZIP archive is not actually compressed! The PNG files are already as compressed<br>as they can reasonably get, and there is unlikely to be any redundancy between files.</p>"},{"title":"Android事件分发机制（二）","_content":"\nViewGroup进行事件分发的过程中，多次把事件传递给了子View，开始View的事件分发。那么，View的事件分发如何进行？\n<!--more-->\n关于View事件分发的几个问题：\n\n1. View进行事件分发的目的？\n\n确定事件能否被消费，以及响应事件具体的类型。\n\n2. View什么情况下会消费事件？\n\n（1）View设置的OnTouchListener，返回true。\n\n（2）重写View的onTouchEvent()方法时，返回true。\n\n（3）View为可点击状态，默认消费事件。例如Button，CheckBox，ImageButton等。\n\n3. View进行事件响应的顺序？\n\nOnTouchListener --> onTouchEvent --> OnLongClickListener --> OnClickListener。\n\n### View的事件分发\n\nView的事件分发主要涉及两个方法：\n\n（1）public boolean dispatchTouchEvent(MotionEvent event)\n\n（2）public boolean onTouchEvent(MotionEvent event)\n\n1. 检测是否设置OnTouchListener\n```python\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n```\n先检测View是否有设置OnTouchListener，如果有设置，调用监听器的回调方法。回调方法返回true，消费事件，即view.dispatchTouchEvent()值为true，相当于告诉ViewGroup，当前事件被消费了。\n\n2. 调用View自身的onTouchEvent()方法\n```python\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n```\nView未设置OnTouchListener，或OnTouchListener中onTouch()回调方法返回值为false，则继续调用View自身的onTouchEvent()方法。如果onTouchEvent()方法返回true，即消费了事件，返回false，未消费事件。\n\n事件传递给onTouchEvent()方法后，需要在其中确认事件类型的响应顺序，下面进入这个方法：\n\n（1）判断View使能\n```python\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n```\nView为DISABLED，被禁用，且不可点击时，直接返回false，告诉ViewGroup，自己没有消费事件。但如果被禁用，却是可点击的（点击，长点击等），依然会返回true。这种情况下View什么也没做，依然把事件消费了。\n\n（2）View未被禁用，继续处理事件\n```python\nif (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {\n//省略\nreturn true;\n}\n```\n只要View是clickable，或者悬停、长按时可显示工具提示，就会返回true，消费事件。\n\n（3）关于点击和长按事件的处理\n```python\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n```\n在手指抬起，View收到ACTION_UP时，先检测是否是长按。如果不是长按，则执行removeLongPressCallback()，移除长按的CheckForLongPress对象，系统不会对长按进行响应。否则，执行performClick()，开始调用点击事件监听器中的回调方法，进行事件响应。\n\n# 总结\nViewGroup拿到事件后，先调用了自己的onInterceptTouchEvent()判断是否要进行拦截。如果拦截，则会将ViewGroup当成View进行事件分发。不拦截，则遍历其中的子View，挨个询问里面的子View有没有要消费事件的。消费，则事件传递结束，不消费，传递给下一个View，都不消费，则又传回到ViewGroup，把自己当成View进行事件分发。在ViewGroup当成View进行事件分发的时候，若没有消进行消费，这次事件被丢弃。事件传递的整个过程看起来像一个回路，是一个经典的责任链式设计模式。\n\n","source":"_posts/Android_DispatchMotionEvent2.md","raw":"---\ntitle: Android事件分发机制（二）\n---\n\nViewGroup进行事件分发的过程中，多次把事件传递给了子View，开始View的事件分发。那么，View的事件分发如何进行？\n<!--more-->\n关于View事件分发的几个问题：\n\n1. View进行事件分发的目的？\n\n确定事件能否被消费，以及响应事件具体的类型。\n\n2. View什么情况下会消费事件？\n\n（1）View设置的OnTouchListener，返回true。\n\n（2）重写View的onTouchEvent()方法时，返回true。\n\n（3）View为可点击状态，默认消费事件。例如Button，CheckBox，ImageButton等。\n\n3. View进行事件响应的顺序？\n\nOnTouchListener --> onTouchEvent --> OnLongClickListener --> OnClickListener。\n\n### View的事件分发\n\nView的事件分发主要涉及两个方法：\n\n（1）public boolean dispatchTouchEvent(MotionEvent event)\n\n（2）public boolean onTouchEvent(MotionEvent event)\n\n1. 检测是否设置OnTouchListener\n```python\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n```\n先检测View是否有设置OnTouchListener，如果有设置，调用监听器的回调方法。回调方法返回true，消费事件，即view.dispatchTouchEvent()值为true，相当于告诉ViewGroup，当前事件被消费了。\n\n2. 调用View自身的onTouchEvent()方法\n```python\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n```\nView未设置OnTouchListener，或OnTouchListener中onTouch()回调方法返回值为false，则继续调用View自身的onTouchEvent()方法。如果onTouchEvent()方法返回true，即消费了事件，返回false，未消费事件。\n\n事件传递给onTouchEvent()方法后，需要在其中确认事件类型的响应顺序，下面进入这个方法：\n\n（1）判断View使能\n```python\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n```\nView为DISABLED，被禁用，且不可点击时，直接返回false，告诉ViewGroup，自己没有消费事件。但如果被禁用，却是可点击的（点击，长点击等），依然会返回true。这种情况下View什么也没做，依然把事件消费了。\n\n（2）View未被禁用，继续处理事件\n```python\nif (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {\n//省略\nreturn true;\n}\n```\n只要View是clickable，或者悬停、长按时可显示工具提示，就会返回true，消费事件。\n\n（3）关于点击和长按事件的处理\n```python\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n```\n在手指抬起，View收到ACTION_UP时，先检测是否是长按。如果不是长按，则执行removeLongPressCallback()，移除长按的CheckForLongPress对象，系统不会对长按进行响应。否则，执行performClick()，开始调用点击事件监听器中的回调方法，进行事件响应。\n\n# 总结\nViewGroup拿到事件后，先调用了自己的onInterceptTouchEvent()判断是否要进行拦截。如果拦截，则会将ViewGroup当成View进行事件分发。不拦截，则遍历其中的子View，挨个询问里面的子View有没有要消费事件的。消费，则事件传递结束，不消费，传递给下一个View，都不消费，则又传回到ViewGroup，把自己当成View进行事件分发。在ViewGroup当成View进行事件分发的时候，若没有消进行消费，这次事件被丢弃。事件传递的整个过程看起来像一个回路，是一个经典的责任链式设计模式。\n\n","slug":"Android_DispatchMotionEvent2","published":1,"date":"2018-08-04T00:50:26.865Z","updated":"2018-08-04T00:50:26.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdax0001idfsv4cip1dz","content":"<p>ViewGroup进行事件分发的过程中，多次把事件传递给了子View，开始View的事件分发。那么，View的事件分发如何进行？<br><a id=\"more\"></a><br>关于View事件分发的几个问题：</p>\n<ol>\n<li>View进行事件分发的目的？</li>\n</ol>\n<p>确定事件能否被消费，以及响应事件具体的类型。</p>\n<ol start=\"2\">\n<li>View什么情况下会消费事件？</li>\n</ol>\n<p>（1）View设置的OnTouchListener，返回true。</p>\n<p>（2）重写View的onTouchEvent()方法时，返回true。</p>\n<p>（3）View为可点击状态，默认消费事件。例如Button，CheckBox，ImageButton等。</p>\n<ol start=\"3\">\n<li>View进行事件响应的顺序？</li>\n</ol>\n<p>OnTouchListener –&gt; onTouchEvent –&gt; OnLongClickListener –&gt; OnClickListener。</p>\n<h3 id=\"View的事件分发\"><a href=\"#View的事件分发\" class=\"headerlink\" title=\"View的事件分发\"></a>View的事件分发</h3><p>View的事件分发主要涉及两个方法：</p>\n<p>（1）public boolean dispatchTouchEvent(MotionEvent event)</p>\n<p>（2）public boolean onTouchEvent(MotionEvent event)</p>\n<ol>\n<li>检测是否设置OnTouchListener<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenerInfo li = mListenerInfo;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class=\"line\">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">        &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class=\"line\">    result = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先检测View是否有设置OnTouchListener，如果有设置，调用监听器的回调方法。回调方法返回true，消费事件，即view.dispatchTouchEvent()值为true，相当于告诉ViewGroup，当前事件被消费了。</p>\n<ol start=\"2\">\n<li>调用View自身的onTouchEvent()方法<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">    result = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>View未设置OnTouchListener，或OnTouchListener中onTouch()回调方法返回值为false，则继续调用View自身的onTouchEvent()方法。如果onTouchEvent()方法返回true，即消费了事件，返回false，未消费事件。</p>\n<p>事件传递给onTouchEvent()方法后，需要在其中确认事件类型的响应顺序，下面进入这个方法：</p>\n<p>（1）判断View使能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        setPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // A disabled view that <span class=\"keyword\">is</span> clickable still consumes the touch</span><br><span class=\"line\">    // events, it just doesn<span class=\"string\">'t respond to them.</span></span><br><span class=\"line\"><span class=\"string\">    return (((viewFlags &amp; CLICKABLE) == CLICKABLE</span></span><br><span class=\"line\"><span class=\"string\">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span></span><br><span class=\"line\"><span class=\"string\">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>View为DISABLED，被禁用，且不可点击时，直接返回false，告诉ViewGroup，自己没有消费事件。但如果被禁用，却是可点击的（点击，长点击等），依然会返回true。这种情况下View什么也没做，依然把事件消费了。</p>\n<p>（2）View未被禁用，继续处理事件<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\"><span class=\"keyword\">return</span> true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只要View是clickable，或者悬停、长按时可显示工具提示，就会返回true，消费事件。</p>\n<p>（3）关于点击和长按事件的处理<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class=\"line\">    // This <span class=\"keyword\">is</span> a tap, so remove the longpress check</span><br><span class=\"line\">    removeLongPressCallback();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Only perform take click actions <span class=\"keyword\">if</span> we were <span class=\"keyword\">in</span> the pressed state</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!focusTaken) &#123;</span><br><span class=\"line\">        // Use a Runnable <span class=\"keyword\">and</span> post this rather than calling</span><br><span class=\"line\">        // performClick directly. This lets other visual state</span><br><span class=\"line\">        // of the view update before click actions start.</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPerformClick == null) &#123;</span><br><span class=\"line\">            mPerformClick = new PerformClick();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</span><br><span class=\"line\">            performClick();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在手指抬起，View收到ACTION_UP时，先检测是否是长按。如果不是长按，则执行removeLongPressCallback()，移除长按的CheckForLongPress对象，系统不会对长按进行响应。否则，执行performClick()，开始调用点击事件监听器中的回调方法，进行事件响应。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ViewGroup拿到事件后，先调用了自己的onInterceptTouchEvent()判断是否要进行拦截。如果拦截，则会将ViewGroup当成View进行事件分发。不拦截，则遍历其中的子View，挨个询问里面的子View有没有要消费事件的。消费，则事件传递结束，不消费，传递给下一个View，都不消费，则又传回到ViewGroup，把自己当成View进行事件分发。在ViewGroup当成View进行事件分发的时候，若没有消进行消费，这次事件被丢弃。事件传递的整个过程看起来像一个回路，是一个经典的责任链式设计模式。</p>\n","site":{"data":{}},"excerpt":"<p>ViewGroup进行事件分发的过程中，多次把事件传递给了子View，开始View的事件分发。那么，View的事件分发如何进行？<br></p>","more":"<br>关于View事件分发的几个问题：<p></p>\n<ol>\n<li>View进行事件分发的目的？</li>\n</ol>\n<p>确定事件能否被消费，以及响应事件具体的类型。</p>\n<ol start=\"2\">\n<li>View什么情况下会消费事件？</li>\n</ol>\n<p>（1）View设置的OnTouchListener，返回true。</p>\n<p>（2）重写View的onTouchEvent()方法时，返回true。</p>\n<p>（3）View为可点击状态，默认消费事件。例如Button，CheckBox，ImageButton等。</p>\n<ol start=\"3\">\n<li>View进行事件响应的顺序？</li>\n</ol>\n<p>OnTouchListener –&gt; onTouchEvent –&gt; OnLongClickListener –&gt; OnClickListener。</p>\n<h3 id=\"View的事件分发\"><a href=\"#View的事件分发\" class=\"headerlink\" title=\"View的事件分发\"></a>View的事件分发</h3><p>View的事件分发主要涉及两个方法：</p>\n<p>（1）public boolean dispatchTouchEvent(MotionEvent event)</p>\n<p>（2）public boolean onTouchEvent(MotionEvent event)</p>\n<ol>\n<li>检测是否设置OnTouchListener<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenerInfo li = mListenerInfo;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class=\"line\">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">        &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class=\"line\">    result = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先检测View是否有设置OnTouchListener，如果有设置，调用监听器的回调方法。回调方法返回true，消费事件，即view.dispatchTouchEvent()值为true，相当于告诉ViewGroup，当前事件被消费了。</p>\n<ol start=\"2\">\n<li>调用View自身的onTouchEvent()方法<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">    result = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>View未设置OnTouchListener，或OnTouchListener中onTouch()回调方法返回值为false，则继续调用View自身的onTouchEvent()方法。如果onTouchEvent()方法返回true，即消费了事件，返回false，未消费事件。</p>\n<p>事件传递给onTouchEvent()方法后，需要在其中确认事件类型的响应顺序，下面进入这个方法：</p>\n<p>（1）判断View使能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        setPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // A disabled view that <span class=\"keyword\">is</span> clickable still consumes the touch</span><br><span class=\"line\">    // events, it just doesn<span class=\"string\">'t respond to them.</span></span><br><span class=\"line\"><span class=\"string\">    return (((viewFlags &amp; CLICKABLE) == CLICKABLE</span></span><br><span class=\"line\"><span class=\"string\">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span></span><br><span class=\"line\"><span class=\"string\">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>View为DISABLED，被禁用，且不可点击时，直接返回false，告诉ViewGroup，自己没有消费事件。但如果被禁用，却是可点击的（点击，长点击等），依然会返回true。这种情况下View什么也没做，依然把事件消费了。</p>\n<p>（2）View未被禁用，继续处理事件<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\"><span class=\"keyword\">return</span> true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只要View是clickable，或者悬停、长按时可显示工具提示，就会返回true，消费事件。</p>\n<p>（3）关于点击和长按事件的处理<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class=\"line\">    // This <span class=\"keyword\">is</span> a tap, so remove the longpress check</span><br><span class=\"line\">    removeLongPressCallback();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Only perform take click actions <span class=\"keyword\">if</span> we were <span class=\"keyword\">in</span> the pressed state</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!focusTaken) &#123;</span><br><span class=\"line\">        // Use a Runnable <span class=\"keyword\">and</span> post this rather than calling</span><br><span class=\"line\">        // performClick directly. This lets other visual state</span><br><span class=\"line\">        // of the view update before click actions start.</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPerformClick == null) &#123;</span><br><span class=\"line\">            mPerformClick = new PerformClick();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</span><br><span class=\"line\">            performClick();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在手指抬起，View收到ACTION_UP时，先检测是否是长按。如果不是长按，则执行removeLongPressCallback()，移除长按的CheckForLongPress对象，系统不会对长按进行响应。否则，执行performClick()，开始调用点击事件监听器中的回调方法，进行事件响应。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ViewGroup拿到事件后，先调用了自己的onInterceptTouchEvent()判断是否要进行拦截。如果拦截，则会将ViewGroup当成View进行事件分发。不拦截，则遍历其中的子View，挨个询问里面的子View有没有要消费事件的。消费，则事件传递结束，不消费，传递给下一个View，都不消费，则又传回到ViewGroup，把自己当成View进行事件分发。在ViewGroup当成View进行事件分发的时候，若没有消进行消费，这次事件被丢弃。事件传递的整个过程看起来像一个回路，是一个经典的责任链式设计模式。</p>"},{"title":"Ubuntu 14.04 Android 7.1.2源码编译","_content":"&emsp;&emsp;一直想入手Framework，今天终于踏上前进的步伐，从编译环境开始，记录点滴，致多年后的自己。源码的下载这里就暂时不写了，后面有需要再补上去，先介绍环境配置，编译和烧录。\n\n<!--more-->\n\n# 一、安装Open JDK8\n1. 增加更新源仓库\n```python\n$ sudo add-apt-repository ppa:openjdk-r/ppa\n```\n2. 更新\n```python\n$ sudo apt-get update\n```\n3. 安装\n```python\n$ sudo apt-get install openjdk-8-jdk\n```\n4. 配置环境变量，可以选择不同地方进行配置，~/.bashrc，/etc/profile，或/etc/environment\n```python\n$ sudo gedit ~/.bashrc\n```\n\t在其最后面添加如下环境变量\n```python\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport ANDROID_SDK=SDK的安装路径\nexport PATH=${JAVA_HOME}/bin:${ANDROID_SDK}/platform-tools:${ANDROID_SDK}/tools:$PATH\n```\n5. 更新导入，或者重启终端\n```python\n$ source ~/.bashrc\n```\n6. 查看java版本信息\n```python\n$ java -version\nopenjdk version \"1.8.0_91\"\nOpenJDK Runtime Environment (build 1.8.0_91-8u91-b14-0ubuntu4~12.04-b14)\nOpenJDK 64-Bit Server VM (build 25.91-b14, mixed mode)\n```\n\t显示如上信息，说明配置成功\n\n7. 如果有多个java版本，可以设置默认java版本\n例如，再安装了一个java7\n```python\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-openjdk-amd64/bin/java 1070\n$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-openjdk-amd64/bin/javac 1070\n\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 600\n$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-openjdk-amd64/bin/javac 600\n```\n\t此时，可查看当前各种JDK版本和配置默认java版本：\n```python\n$ sudo update-alternatives --config java\n$ sudo update-alternatives --config javac\n```\n\t到这里，Java OpenJdk安装好了，接下来是安装编译时需要的各种依赖包。\n\n# 二、安装依赖包\n+ 搜集的需要安装的依赖包如下:\n```python\n$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc u-boot-tools lib32z1 lib32ncurses5 lib32bz2-1.0 gcc-arm-linux-gnueabi make ncurses-dev gawk python-lunch u-boot-tools\n```\n&emsp;&emsp;环境基本OK，接下来可以编译了。由于是先配好再来写的这份文档，如果有一两个细节疏忽，网上的前辈们有很多经验帖可以参考，也欢迎在下面评论区留言指正。\n\n# 三、开始编译\n1. 先编译内核\n不同的厂商不一样，这里只贴全志的，仅供参考\n```python\n$ cd lichee\n$ ./build.sh config\n\nWelcome to mkscript setup progress\nAll available chips:\n   0. sun50iw1p1\n   1. sun8iw1p1\n   2. sun8iw3p1\n   3. sun8iw5p1\n   4. sun8iw6p1\n   5. sun8iw7p1\n   6. sun8iw8p1\n   7. sun8iw9p1\n   8. sun9iw1p1\nChoice: 4\nAll available platforms:\n   0. android\n   1. dragonboard\n   2. linux\n   3. camdroid\n   4. secureandroid\nChoice: 0\nAll available kernel:\n   0. linux-3.4\nChoice: 0\nAll available boards:\n   0. f1\n   1. fpga\n   2. n1\n   3. perf1_v1_0\n   4. perf2_v1_0\n   5. perf3_v1_0\n   6. qc\nChoice: 0\n\n$ ./build.sh\n```\n2. 进入源码根目录，执行源码环境配置文件\n```python\n$ source build/envsetup.sh\n```\n3. 执行lunch，选择要编译的板\n```python\n$ lunch\n```\n4. 拷贝内核至输出目录\n```python\n$ extract-bsp\n```\n5. 开始编译\n```python\n$ make -j8 //8为线程数，可依据电脑配置设置\n```\n编译成功之后，生成的文件会在out/target目录下\n6. 打包成烧录img\n```python\n$ pack -d\n```\n\n# 四、烧录\n烧录的方式有两种：\n+ Windows软件烧录\n+ fastboot烧录，按区烧录img\n\n第一种烧录的是上面打包好的img，下载烧录软件即可完成。下面介绍的是第二种情况的烧录：\n1. 重启进入烧录模式\n```python\n$ adb reboot bootloader\n```\n2. 查看设备\n```python\n$ fastboot devices\n```\n3. 如果无驱动，增加驱动\n```python\n$ sudo vim /etc/udev/rules.d/50-android.rules\n```\n\t先lsusb，查看id，在文件中加入ATTR{idVendor}和ATTRS{idProduct}，格式如下\n```python\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0012\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"1b8e\", ATTRS{idProduct}==\"c003\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0489\", ATTRS{idProduct}==\"0007\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"18d1\", ATTRS{idProduct}==\"4ee7\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"1f3a\", ATTRS{idProduct}==\"1010\", MODE=\"0666\", GROUP=\"plugdev\"\n```\n4. 重启udev\n```python\n$ sudo service udev restart\n```\n5. fastboot devices检测到设备后，开始烧录img\n```python\n$ fastboot flash boot out/target/product/octopus-f1/boot.img\n$ fastboot flash system out/target/product/octopus-f1/system.img\n$ fastboot reboot\n```\n\n# 五、编译错误处理\n1. 内存不足\n+ 修改文件jack-admin\n```python\n$ sudo gedit ./prebuilts/sdk/tools/jack-admin\n```\n找到参数JACK_SERVER_VM_ARGUMENTS，修改为  \nJACK_SERVER_VM_ARGUMENTS=\"${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation <font color=#ff0000>-Xmx3g</font>}\"\n如果依然提示内存不足，再改大一点。\n+ 重启jack server\n```python\n$ ./prebuilts/sdk/tools/jack-admin  stop-server\n$ ./prebuilts/sdk/tools/jack-admin  start-server\n```\n&emsp;&emsp;编译烧录上没有很长内容，比较简单，但是在没有自己走一遍之前，免不了有无从下手的感觉，编译烧录成功了，及时记录下相关知识，方便以后查阅，也希望对有相同兴趣爱好的人有所帮助。学无止境，共勉之！\n\n","source":"_posts/Ubuntu_14.04_Android_7.1.2_env_config.md","raw":"---\ntitle: Ubuntu 14.04 Android 7.1.2源码编译\n---\n&emsp;&emsp;一直想入手Framework，今天终于踏上前进的步伐，从编译环境开始，记录点滴，致多年后的自己。源码的下载这里就暂时不写了，后面有需要再补上去，先介绍环境配置，编译和烧录。\n\n<!--more-->\n\n# 一、安装Open JDK8\n1. 增加更新源仓库\n```python\n$ sudo add-apt-repository ppa:openjdk-r/ppa\n```\n2. 更新\n```python\n$ sudo apt-get update\n```\n3. 安装\n```python\n$ sudo apt-get install openjdk-8-jdk\n```\n4. 配置环境变量，可以选择不同地方进行配置，~/.bashrc，/etc/profile，或/etc/environment\n```python\n$ sudo gedit ~/.bashrc\n```\n\t在其最后面添加如下环境变量\n```python\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport ANDROID_SDK=SDK的安装路径\nexport PATH=${JAVA_HOME}/bin:${ANDROID_SDK}/platform-tools:${ANDROID_SDK}/tools:$PATH\n```\n5. 更新导入，或者重启终端\n```python\n$ source ~/.bashrc\n```\n6. 查看java版本信息\n```python\n$ java -version\nopenjdk version \"1.8.0_91\"\nOpenJDK Runtime Environment (build 1.8.0_91-8u91-b14-0ubuntu4~12.04-b14)\nOpenJDK 64-Bit Server VM (build 25.91-b14, mixed mode)\n```\n\t显示如上信息，说明配置成功\n\n7. 如果有多个java版本，可以设置默认java版本\n例如，再安装了一个java7\n```python\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-openjdk-amd64/bin/java 1070\n$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-openjdk-amd64/bin/javac 1070\n\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 600\n$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-openjdk-amd64/bin/javac 600\n```\n\t此时，可查看当前各种JDK版本和配置默认java版本：\n```python\n$ sudo update-alternatives --config java\n$ sudo update-alternatives --config javac\n```\n\t到这里，Java OpenJdk安装好了，接下来是安装编译时需要的各种依赖包。\n\n# 二、安装依赖包\n+ 搜集的需要安装的依赖包如下:\n```python\n$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc u-boot-tools lib32z1 lib32ncurses5 lib32bz2-1.0 gcc-arm-linux-gnueabi make ncurses-dev gawk python-lunch u-boot-tools\n```\n&emsp;&emsp;环境基本OK，接下来可以编译了。由于是先配好再来写的这份文档，如果有一两个细节疏忽，网上的前辈们有很多经验帖可以参考，也欢迎在下面评论区留言指正。\n\n# 三、开始编译\n1. 先编译内核\n不同的厂商不一样，这里只贴全志的，仅供参考\n```python\n$ cd lichee\n$ ./build.sh config\n\nWelcome to mkscript setup progress\nAll available chips:\n   0. sun50iw1p1\n   1. sun8iw1p1\n   2. sun8iw3p1\n   3. sun8iw5p1\n   4. sun8iw6p1\n   5. sun8iw7p1\n   6. sun8iw8p1\n   7. sun8iw9p1\n   8. sun9iw1p1\nChoice: 4\nAll available platforms:\n   0. android\n   1. dragonboard\n   2. linux\n   3. camdroid\n   4. secureandroid\nChoice: 0\nAll available kernel:\n   0. linux-3.4\nChoice: 0\nAll available boards:\n   0. f1\n   1. fpga\n   2. n1\n   3. perf1_v1_0\n   4. perf2_v1_0\n   5. perf3_v1_0\n   6. qc\nChoice: 0\n\n$ ./build.sh\n```\n2. 进入源码根目录，执行源码环境配置文件\n```python\n$ source build/envsetup.sh\n```\n3. 执行lunch，选择要编译的板\n```python\n$ lunch\n```\n4. 拷贝内核至输出目录\n```python\n$ extract-bsp\n```\n5. 开始编译\n```python\n$ make -j8 //8为线程数，可依据电脑配置设置\n```\n编译成功之后，生成的文件会在out/target目录下\n6. 打包成烧录img\n```python\n$ pack -d\n```\n\n# 四、烧录\n烧录的方式有两种：\n+ Windows软件烧录\n+ fastboot烧录，按区烧录img\n\n第一种烧录的是上面打包好的img，下载烧录软件即可完成。下面介绍的是第二种情况的烧录：\n1. 重启进入烧录模式\n```python\n$ adb reboot bootloader\n```\n2. 查看设备\n```python\n$ fastboot devices\n```\n3. 如果无驱动，增加驱动\n```python\n$ sudo vim /etc/udev/rules.d/50-android.rules\n```\n\t先lsusb，查看id，在文件中加入ATTR{idVendor}和ATTRS{idProduct}，格式如下\n```python\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0012\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"1b8e\", ATTRS{idProduct}==\"c003\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0489\", ATTRS{idProduct}==\"0007\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"18d1\", ATTRS{idProduct}==\"4ee7\", MODE=\"0666\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"1f3a\", ATTRS{idProduct}==\"1010\", MODE=\"0666\", GROUP=\"plugdev\"\n```\n4. 重启udev\n```python\n$ sudo service udev restart\n```\n5. fastboot devices检测到设备后，开始烧录img\n```python\n$ fastboot flash boot out/target/product/octopus-f1/boot.img\n$ fastboot flash system out/target/product/octopus-f1/system.img\n$ fastboot reboot\n```\n\n# 五、编译错误处理\n1. 内存不足\n+ 修改文件jack-admin\n```python\n$ sudo gedit ./prebuilts/sdk/tools/jack-admin\n```\n找到参数JACK_SERVER_VM_ARGUMENTS，修改为  \nJACK_SERVER_VM_ARGUMENTS=\"${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation <font color=#ff0000>-Xmx3g</font>}\"\n如果依然提示内存不足，再改大一点。\n+ 重启jack server\n```python\n$ ./prebuilts/sdk/tools/jack-admin  stop-server\n$ ./prebuilts/sdk/tools/jack-admin  start-server\n```\n&emsp;&emsp;编译烧录上没有很长内容，比较简单，但是在没有自己走一遍之前，免不了有无从下手的感觉，编译烧录成功了，及时记录下相关知识，方便以后查阅，也希望对有相同兴趣爱好的人有所帮助。学无止境，共勉之！\n\n","slug":"Ubuntu_14.04_Android_7.1.2_env_config","published":1,"date":"2018-07-17T02:54:34.530Z","updated":"2018-07-17T02:54:34.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdaz0002idfsg5kd85uk","content":"<p>&emsp;&emsp;一直想入手Framework，今天终于踏上前进的步伐，从编译环境开始，记录点滴，致多年后的自己。源码的下载这里就暂时不写了，后面有需要再补上去，先介绍环境配置，编译和烧录。</p>\n<a id=\"more\"></a>\n<h1 id=\"一、安装Open-JDK8\"><a href=\"#一、安装Open-JDK8\" class=\"headerlink\" title=\"一、安装Open JDK8\"></a>一、安装Open JDK8</h1><ol>\n<li><p>增加更新源仓库</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:openjdk-r/ppa</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install openjdk<span class=\"number\">-8</span>-jdk</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置环境变量，可以选择不同地方进行配置，~/.bashrc，/etc/profile，或/etc/environment</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p> 在其最后面添加如下环境变量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64</span><br><span class=\"line\">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class=\"line\">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class=\"line\">export ANDROID_SDK=SDK的安装路径</span><br><span class=\"line\">export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;ANDROID_SDK&#125;/platform-tools:$&#123;ANDROID_SDK&#125;/tools:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新导入，或者重启终端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看java版本信息</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">openjdk version <span class=\"string\">\"1.8.0_91\"</span></span><br><span class=\"line\">OpenJDK Runtime Environment (build <span class=\"number\">1.8</span><span class=\"number\">.0</span>_91<span class=\"number\">-8</span>u91-b14<span class=\"number\">-0</span>ubuntu4~<span class=\"number\">12.04</span>-b14)</span><br><span class=\"line\">OpenJDK <span class=\"number\">64</span>-Bit Server VM (build <span class=\"number\">25.91</span>-b14, mixed mode)</span><br></pre></td></tr></table></figure>\n<p> 显示如上信息，说明配置成功</p>\n</li>\n<li><p>如果有多个java版本，可以设置默认java版本<br>例如，再安装了一个java7</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java<span class=\"number\">-7</span>-openjdk-amd64/bin/java <span class=\"number\">1070</span></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java<span class=\"number\">-7</span>-openjdk-amd64/bin/javac <span class=\"number\">1070</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64/bin/java <span class=\"number\">600</span></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64/bin/javac <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n<p> 此时，可查看当前各种JDK版本和配置默认java版本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo update-alternatives --config java</span><br><span class=\"line\">$ sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>\n<p> 到这里，Java OpenJdk安装好了，接下来是安装编译时需要的各种依赖包。</p>\n</li>\n</ol>\n<h1 id=\"二、安装依赖包\"><a href=\"#二、安装依赖包\" class=\"headerlink\" title=\"二、安装依赖包\"></a>二、安装依赖包</h1><ul>\n<li>搜集的需要安装的依赖包如下:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc u-boot-tools lib32z1 lib32ncurses5 lib32bz2<span class=\"number\">-1.0</span> gcc-arm-linux-gnueabi make ncurses-dev gawk python-lunch u-boot-tools</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&emsp;&emsp;环境基本OK，接下来可以编译了。由于是先配好再来写的这份文档，如果有一两个细节疏忽，网上的前辈们有很多经验帖可以参考，也欢迎在下面评论区留言指正。</p>\n<h1 id=\"三、开始编译\"><a href=\"#三、开始编译\" class=\"headerlink\" title=\"三、开始编译\"></a>三、开始编译</h1><ol>\n<li><p>先编译内核<br>不同的厂商不一样，这里只贴全志的，仅供参考</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd lichee</span><br><span class=\"line\">$ ./build.sh config</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to mkscript setup progress</span><br><span class=\"line\">All available chips:</span><br><span class=\"line\">   <span class=\"number\">0.</span> sun50iw1p1</span><br><span class=\"line\">   <span class=\"number\">1.</span> sun8iw1p1</span><br><span class=\"line\">   <span class=\"number\">2.</span> sun8iw3p1</span><br><span class=\"line\">   <span class=\"number\">3.</span> sun8iw5p1</span><br><span class=\"line\">   <span class=\"number\">4.</span> sun8iw6p1</span><br><span class=\"line\">   <span class=\"number\">5.</span> sun8iw7p1</span><br><span class=\"line\">   <span class=\"number\">6.</span> sun8iw8p1</span><br><span class=\"line\">   <span class=\"number\">7.</span> sun8iw9p1</span><br><span class=\"line\">   <span class=\"number\">8.</span> sun9iw1p1</span><br><span class=\"line\">Choice: <span class=\"number\">4</span></span><br><span class=\"line\">All available platforms:</span><br><span class=\"line\">   <span class=\"number\">0.</span> android</span><br><span class=\"line\">   <span class=\"number\">1.</span> dragonboard</span><br><span class=\"line\">   <span class=\"number\">2.</span> linux</span><br><span class=\"line\">   <span class=\"number\">3.</span> camdroid</span><br><span class=\"line\">   <span class=\"number\">4.</span> secureandroid</span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\">All available kernel:</span><br><span class=\"line\">   <span class=\"number\">0.</span> linux<span class=\"number\">-3.4</span></span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\">All available boards:</span><br><span class=\"line\">   <span class=\"number\">0.</span> f1</span><br><span class=\"line\">   <span class=\"number\">1.</span> fpga</span><br><span class=\"line\">   <span class=\"number\">2.</span> n1</span><br><span class=\"line\">   <span class=\"number\">3.</span> perf1_v1_0</span><br><span class=\"line\">   <span class=\"number\">4.</span> perf2_v1_0</span><br><span class=\"line\">   <span class=\"number\">5.</span> perf3_v1_0</span><br><span class=\"line\">   <span class=\"number\">6.</span> qc</span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ./build.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入源码根目录，执行源码环境配置文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source build/envsetup.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行lunch，选择要编译的板</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lunch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拷贝内核至输出目录</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ extract-bsp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开始编译</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -j8 //<span class=\"number\">8</span>为线程数，可依据电脑配置设置</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编译成功之后，生成的文件会在out/target目录下</p>\n<ol start=\"6\">\n<li>打包成烧录img<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pack -d</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"四、烧录\"><a href=\"#四、烧录\" class=\"headerlink\" title=\"四、烧录\"></a>四、烧录</h1><p>烧录的方式有两种：</p>\n<ul>\n<li>Windows软件烧录</li>\n<li>fastboot烧录，按区烧录img</li>\n</ul>\n<p>第一种烧录的是上面打包好的img，下载烧录软件即可完成。下面介绍的是第二种情况的烧录：</p>\n<ol>\n<li><p>重启进入烧录模式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看设备</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fastboot devices</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果无驱动，增加驱动</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/udev/rules.d/<span class=\"number\">50</span>-android.rules</span><br></pre></td></tr></table></figure>\n<p> 先lsusb，查看id，在文件中加入ATTR{idVendor}和ATTRS{idProduct}，格式如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"0012\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"1b8e\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"c003\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"0489\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"0007\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"18d1\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"4ee7\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"1f3a\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"1010\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启udev</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo service udev restart</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fastboot devices检测到设备后，开始烧录img</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fastboot flash boot out/target/product/octopus-f1/boot.img</span><br><span class=\"line\">$ fastboot flash system out/target/product/octopus-f1/system.img</span><br><span class=\"line\">$ fastboot reboot</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"五、编译错误处理\"><a href=\"#五、编译错误处理\" class=\"headerlink\" title=\"五、编译错误处理\"></a>五、编译错误处理</h1><ol>\n<li>内存不足</li>\n</ol>\n<ul>\n<li>修改文件jack-admin<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gedit ./prebuilts/sdk/tools/jack-admin</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>找到参数JACK_SERVER_VM_ARGUMENTS，修改为<br>JACK_SERVER_VM_ARGUMENTS=”${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation <font color=\"#ff0000\">-Xmx3g</font>}”<br>如果依然提示内存不足，再改大一点。</p>\n<ul>\n<li>重启jack server<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./prebuilts/sdk/tools/jack-admin  stop-server</span><br><span class=\"line\">$ ./prebuilts/sdk/tools/jack-admin  start-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&emsp;&emsp;编译烧录上没有很长内容，比较简单，但是在没有自己走一遍之前，免不了有无从下手的感觉，编译烧录成功了，及时记录下相关知识，方便以后查阅，也希望对有相同兴趣爱好的人有所帮助。学无止境，共勉之！</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;一直想入手Framework，今天终于踏上前进的步伐，从编译环境开始，记录点滴，致多年后的自己。源码的下载这里就暂时不写了，后面有需要再补上去，先介绍环境配置，编译和烧录。</p>","more":"<h1 id=\"一、安装Open-JDK8\"><a href=\"#一、安装Open-JDK8\" class=\"headerlink\" title=\"一、安装Open JDK8\"></a>一、安装Open JDK8</h1><ol>\n<li><p>增加更新源仓库</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:openjdk-r/ppa</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install openjdk<span class=\"number\">-8</span>-jdk</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置环境变量，可以选择不同地方进行配置，~/.bashrc，/etc/profile，或/etc/environment</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p> 在其最后面添加如下环境变量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64</span><br><span class=\"line\">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class=\"line\">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class=\"line\">export ANDROID_SDK=SDK的安装路径</span><br><span class=\"line\">export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;ANDROID_SDK&#125;/platform-tools:$&#123;ANDROID_SDK&#125;/tools:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新导入，或者重启终端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看java版本信息</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">openjdk version <span class=\"string\">\"1.8.0_91\"</span></span><br><span class=\"line\">OpenJDK Runtime Environment (build <span class=\"number\">1.8</span><span class=\"number\">.0</span>_91<span class=\"number\">-8</span>u91-b14<span class=\"number\">-0</span>ubuntu4~<span class=\"number\">12.04</span>-b14)</span><br><span class=\"line\">OpenJDK <span class=\"number\">64</span>-Bit Server VM (build <span class=\"number\">25.91</span>-b14, mixed mode)</span><br></pre></td></tr></table></figure>\n<p> 显示如上信息，说明配置成功</p>\n</li>\n<li><p>如果有多个java版本，可以设置默认java版本<br>例如，再安装了一个java7</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java<span class=\"number\">-7</span>-openjdk-amd64/bin/java <span class=\"number\">1070</span></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java<span class=\"number\">-7</span>-openjdk-amd64/bin/javac <span class=\"number\">1070</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64/bin/java <span class=\"number\">600</span></span><br><span class=\"line\">$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java<span class=\"number\">-8</span>-openjdk-amd64/bin/javac <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n<p> 此时，可查看当前各种JDK版本和配置默认java版本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo update-alternatives --config java</span><br><span class=\"line\">$ sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>\n<p> 到这里，Java OpenJdk安装好了，接下来是安装编译时需要的各种依赖包。</p>\n</li>\n</ol>\n<h1 id=\"二、安装依赖包\"><a href=\"#二、安装依赖包\" class=\"headerlink\" title=\"二、安装依赖包\"></a>二、安装依赖包</h1><ul>\n<li>搜集的需要安装的依赖包如下:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc u-boot-tools lib32z1 lib32ncurses5 lib32bz2<span class=\"number\">-1.0</span> gcc-arm-linux-gnueabi make ncurses-dev gawk python-lunch u-boot-tools</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&emsp;&emsp;环境基本OK，接下来可以编译了。由于是先配好再来写的这份文档，如果有一两个细节疏忽，网上的前辈们有很多经验帖可以参考，也欢迎在下面评论区留言指正。</p>\n<h1 id=\"三、开始编译\"><a href=\"#三、开始编译\" class=\"headerlink\" title=\"三、开始编译\"></a>三、开始编译</h1><ol>\n<li><p>先编译内核<br>不同的厂商不一样，这里只贴全志的，仅供参考</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd lichee</span><br><span class=\"line\">$ ./build.sh config</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to mkscript setup progress</span><br><span class=\"line\">All available chips:</span><br><span class=\"line\">   <span class=\"number\">0.</span> sun50iw1p1</span><br><span class=\"line\">   <span class=\"number\">1.</span> sun8iw1p1</span><br><span class=\"line\">   <span class=\"number\">2.</span> sun8iw3p1</span><br><span class=\"line\">   <span class=\"number\">3.</span> sun8iw5p1</span><br><span class=\"line\">   <span class=\"number\">4.</span> sun8iw6p1</span><br><span class=\"line\">   <span class=\"number\">5.</span> sun8iw7p1</span><br><span class=\"line\">   <span class=\"number\">6.</span> sun8iw8p1</span><br><span class=\"line\">   <span class=\"number\">7.</span> sun8iw9p1</span><br><span class=\"line\">   <span class=\"number\">8.</span> sun9iw1p1</span><br><span class=\"line\">Choice: <span class=\"number\">4</span></span><br><span class=\"line\">All available platforms:</span><br><span class=\"line\">   <span class=\"number\">0.</span> android</span><br><span class=\"line\">   <span class=\"number\">1.</span> dragonboard</span><br><span class=\"line\">   <span class=\"number\">2.</span> linux</span><br><span class=\"line\">   <span class=\"number\">3.</span> camdroid</span><br><span class=\"line\">   <span class=\"number\">4.</span> secureandroid</span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\">All available kernel:</span><br><span class=\"line\">   <span class=\"number\">0.</span> linux<span class=\"number\">-3.4</span></span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\">All available boards:</span><br><span class=\"line\">   <span class=\"number\">0.</span> f1</span><br><span class=\"line\">   <span class=\"number\">1.</span> fpga</span><br><span class=\"line\">   <span class=\"number\">2.</span> n1</span><br><span class=\"line\">   <span class=\"number\">3.</span> perf1_v1_0</span><br><span class=\"line\">   <span class=\"number\">4.</span> perf2_v1_0</span><br><span class=\"line\">   <span class=\"number\">5.</span> perf3_v1_0</span><br><span class=\"line\">   <span class=\"number\">6.</span> qc</span><br><span class=\"line\">Choice: <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ./build.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入源码根目录，执行源码环境配置文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source build/envsetup.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行lunch，选择要编译的板</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lunch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拷贝内核至输出目录</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ extract-bsp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开始编译</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make -j8 //<span class=\"number\">8</span>为线程数，可依据电脑配置设置</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编译成功之后，生成的文件会在out/target目录下</p>\n<ol start=\"6\">\n<li>打包成烧录img<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pack -d</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"四、烧录\"><a href=\"#四、烧录\" class=\"headerlink\" title=\"四、烧录\"></a>四、烧录</h1><p>烧录的方式有两种：</p>\n<ul>\n<li>Windows软件烧录</li>\n<li>fastboot烧录，按区烧录img</li>\n</ul>\n<p>第一种烧录的是上面打包好的img，下载烧录软件即可完成。下面介绍的是第二种情况的烧录：</p>\n<ol>\n<li><p>重启进入烧录模式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看设备</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fastboot devices</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果无驱动，增加驱动</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/udev/rules.d/<span class=\"number\">50</span>-android.rules</span><br></pre></td></tr></table></figure>\n<p> 先lsusb，查看id，在文件中加入ATTR{idVendor}和ATTRS{idProduct}，格式如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"0012\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"1b8e\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"c003\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"0489\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"0007\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"18d1\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"4ee7\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">\"usb\"</span>, ATTR&#123;idVendor&#125;==<span class=\"string\">\"1f3a\"</span>, ATTRS&#123;idProduct&#125;==<span class=\"string\">\"1010\"</span>, MODE=<span class=\"string\">\"0666\"</span>, GROUP=<span class=\"string\">\"plugdev\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启udev</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo service udev restart</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fastboot devices检测到设备后，开始烧录img</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fastboot flash boot out/target/product/octopus-f1/boot.img</span><br><span class=\"line\">$ fastboot flash system out/target/product/octopus-f1/system.img</span><br><span class=\"line\">$ fastboot reboot</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"五、编译错误处理\"><a href=\"#五、编译错误处理\" class=\"headerlink\" title=\"五、编译错误处理\"></a>五、编译错误处理</h1><ol>\n<li>内存不足</li>\n</ol>\n<ul>\n<li>修改文件jack-admin<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gedit ./prebuilts/sdk/tools/jack-admin</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>找到参数JACK_SERVER_VM_ARGUMENTS，修改为<br>JACK_SERVER_VM_ARGUMENTS=”${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation <font color=\"#ff0000\">-Xmx3g</font>}”<br>如果依然提示内存不足，再改大一点。</p>\n<ul>\n<li>重启jack server<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./prebuilts/sdk/tools/jack-admin  stop-server</span><br><span class=\"line\">$ ./prebuilts/sdk/tools/jack-admin  start-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&emsp;&emsp;编译烧录上没有很长内容，比较简单，但是在没有自己走一遍之前，免不了有无从下手的感觉，编译烧录成功了，及时记录下相关知识，方便以后查阅，也希望对有相同兴趣爱好的人有所帮助。学无止境，共勉之！</p>"},{"title":"LinearLayout android:layout_weight属性用法总结","_content":"\n&emsp;&emsp;`LinearLayout`，很常用的一种布局，当在使用这种布局方式时，为了达到较好的屏幕适配效果，可以选择使用`android:layout_weight`属性。当为布局中的每个组件指定了大小和权重之后，我们的android系统如何计算各组件实际所占空间呢？\n<!--more-->\n贴个自己常用的计算方法：\n**实际大小=指定大小+（屏幕大小-（所有组件大小的和））\\*权重比例。**\n\n用一屏幕的大小减去所有组件大小的和，得到剩余大小，或理解为可分配空间，该值可为负。然后用我们给某个组件设定的值，加上其在剩余大小中按比例计算后的值，就是该组件最后的实际大小。\n可用空间=屏幕大小-所有组件大小的和，\n实际大小=指定大小+可用空间\\*权重比例，\n所以最后为：\n实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。\n\n示例:\n以`android:layout_width`为例，验证计算方式（屏幕宽度：L）\n在`LinearLayout`中放置三个按钮，分别为Button1，Button2，Button3，`android:layout_height=\"wrap_content\"`均指定为包裹内容，每个Button的`android:layout_weight`分别为1，2，3。\n\n依据`android:layout_width`属性的设置，分三种情况：\n1. `android:layout_width=\"0dp\"`时：\n组件大小=0+（L-（0+0+0））\\*权重比例，组件大小和权重成正比。\n各Button占的宽度：\nButton1=0+(L-(0+0+0))\\*(1/6)，为1/6L；\nButton2=0+(L-(0+0+0))\\*(2/6)，为2/6L；\nButton3=0+(L-(0+0+0))\\*(3/6)，为3/6L。\n所以Button1:Button2:Button3 = 1:2:3。\n\n    ![layout_width=\"0dp\"][]\n\n2. `android:layout_width=\"match_parent\"`时：\n组件大小=L+（L-（L+L+L））\\*权重比例，组件大小和权重成反比。\n如果前面组件已经占满屏幕，则剩余组件无法获得空间，不可见。\n各Button占的宽度：\n每个Button的`layout_width`指定为`match_parent`，即表示每个Button指定大小为父组件宽度，即L。\nButton1=L+(L-(L+L+L))\\*(1/6)，为4/6L；\nButton2=L+(L-(L+L+L))\\*(2/6)，为2/6L；\nButton3=L+L(L-(L+L+L))\\*(3/6)，为0。\n所以Button1:Button2=2:1，Button3不可见。\n\n    ![layout_width=\"match_parent\"][]\n\n\n3. `android:layout_width=\"wrap_content\"`时：\n组件大小=所需大小+(L-各组件所需大小和)\\*权重比例，剩余大小即(L-各组件所需大小和)为正，则为正比，否则为反比。\n该情况和组件内容占用大小有关，所以布局上并不是很明显的比例关系，因为比例关系仅指剩余大小的比例：\n    剩余大小为正，即屏幕空间足够，所占空间和权重成正比。\n    ![layout_width=\"wrap_content\" enough][]\n\n    剩余大小为负，即屏幕空间不足，所占空间和权重成反比，下面的图可能有点难看，希望想表达的意思到了。\n    ![layout_width=\"wrap_content\" less][]\n\n`LinearLayout`的`android:layout_weight`属性用起来很简单，但是如果想深入理解其原理，就需要参考源代码了。\n\n[layout_width=\"0dp\"]: linearLayout/width_0.png \"0 dp\"\n[layout_width=\"match_parent\"]: linearLayout/width_match.png \"match_parent\"\n[layout_width=\"wrap_content\" enough]: linearLayout/width_enough.png \"wrap_content enough\"\n[layout_width=\"wrap_content\" less]: linearLayout/width_less.png \"wrap_content less\"\n","source":"_posts/linearLayout.md","raw":"---\ntitle: LinearLayout android:layout_weight属性用法总结\n---\n\n&emsp;&emsp;`LinearLayout`，很常用的一种布局，当在使用这种布局方式时，为了达到较好的屏幕适配效果，可以选择使用`android:layout_weight`属性。当为布局中的每个组件指定了大小和权重之后，我们的android系统如何计算各组件实际所占空间呢？\n<!--more-->\n贴个自己常用的计算方法：\n**实际大小=指定大小+（屏幕大小-（所有组件大小的和））\\*权重比例。**\n\n用一屏幕的大小减去所有组件大小的和，得到剩余大小，或理解为可分配空间，该值可为负。然后用我们给某个组件设定的值，加上其在剩余大小中按比例计算后的值，就是该组件最后的实际大小。\n可用空间=屏幕大小-所有组件大小的和，\n实际大小=指定大小+可用空间\\*权重比例，\n所以最后为：\n实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。\n\n示例:\n以`android:layout_width`为例，验证计算方式（屏幕宽度：L）\n在`LinearLayout`中放置三个按钮，分别为Button1，Button2，Button3，`android:layout_height=\"wrap_content\"`均指定为包裹内容，每个Button的`android:layout_weight`分别为1，2，3。\n\n依据`android:layout_width`属性的设置，分三种情况：\n1. `android:layout_width=\"0dp\"`时：\n组件大小=0+（L-（0+0+0））\\*权重比例，组件大小和权重成正比。\n各Button占的宽度：\nButton1=0+(L-(0+0+0))\\*(1/6)，为1/6L；\nButton2=0+(L-(0+0+0))\\*(2/6)，为2/6L；\nButton3=0+(L-(0+0+0))\\*(3/6)，为3/6L。\n所以Button1:Button2:Button3 = 1:2:3。\n\n    ![layout_width=\"0dp\"][]\n\n2. `android:layout_width=\"match_parent\"`时：\n组件大小=L+（L-（L+L+L））\\*权重比例，组件大小和权重成反比。\n如果前面组件已经占满屏幕，则剩余组件无法获得空间，不可见。\n各Button占的宽度：\n每个Button的`layout_width`指定为`match_parent`，即表示每个Button指定大小为父组件宽度，即L。\nButton1=L+(L-(L+L+L))\\*(1/6)，为4/6L；\nButton2=L+(L-(L+L+L))\\*(2/6)，为2/6L；\nButton3=L+L(L-(L+L+L))\\*(3/6)，为0。\n所以Button1:Button2=2:1，Button3不可见。\n\n    ![layout_width=\"match_parent\"][]\n\n\n3. `android:layout_width=\"wrap_content\"`时：\n组件大小=所需大小+(L-各组件所需大小和)\\*权重比例，剩余大小即(L-各组件所需大小和)为正，则为正比，否则为反比。\n该情况和组件内容占用大小有关，所以布局上并不是很明显的比例关系，因为比例关系仅指剩余大小的比例：\n    剩余大小为正，即屏幕空间足够，所占空间和权重成正比。\n    ![layout_width=\"wrap_content\" enough][]\n\n    剩余大小为负，即屏幕空间不足，所占空间和权重成反比，下面的图可能有点难看，希望想表达的意思到了。\n    ![layout_width=\"wrap_content\" less][]\n\n`LinearLayout`的`android:layout_weight`属性用起来很简单，但是如果想深入理解其原理，就需要参考源代码了。\n\n[layout_width=\"0dp\"]: linearLayout/width_0.png \"0 dp\"\n[layout_width=\"match_parent\"]: linearLayout/width_match.png \"match_parent\"\n[layout_width=\"wrap_content\" enough]: linearLayout/width_enough.png \"wrap_content enough\"\n[layout_width=\"wrap_content\" less]: linearLayout/width_less.png \"wrap_content less\"\n","slug":"linearLayout","published":1,"date":"2018-07-12T09:01:27.007Z","updated":"2018-07-12T09:01:26.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdb00003idfs0l42vt89","content":"<p>&emsp;&emsp;<code>LinearLayout</code>，很常用的一种布局，当在使用这种布局方式时，为了达到较好的屏幕适配效果，可以选择使用<code>android:layout_weight</code>属性。当为布局中的每个组件指定了大小和权重之后，我们的android系统如何计算各组件实际所占空间呢？<br><a id=\"more\"></a><br>贴个自己常用的计算方法：<br><strong>实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。</strong></p>\n<p>用一屏幕的大小减去所有组件大小的和，得到剩余大小，或理解为可分配空间，该值可为负。然后用我们给某个组件设定的值，加上其在剩余大小中按比例计算后的值，就是该组件最后的实际大小。<br>可用空间=屏幕大小-所有组件大小的和，<br>实际大小=指定大小+可用空间*权重比例，<br>所以最后为：<br>实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。</p>\n<p>示例:<br>以<code>android:layout_width</code>为例，验证计算方式（屏幕宽度：L）<br>在<code>LinearLayout</code>中放置三个按钮，分别为Button1，Button2，Button3，<code>android:layout_height=&quot;wrap_content&quot;</code>均指定为包裹内容，每个Button的<code>android:layout_weight</code>分别为1，2，3。</p>\n<p>依据<code>android:layout_width</code>属性的设置，分三种情况：</p>\n<ol>\n<li><p><code>android:layout_width=&quot;0dp&quot;</code>时：<br>组件大小=0+（L-（0+0+0））*权重比例，组件大小和权重成正比。<br>各Button占的宽度：<br>Button1=0+(L-(0+0+0))*(1/6)，为1/6L；<br>Button2=0+(L-(0+0+0))*(2/6)，为2/6L；<br>Button3=0+(L-(0+0+0))*(3/6)，为3/6L。<br>所以Button1:Button2:Button3 = 1:2:3。</p>\n<p> <img src=\"/2018/07/12/linearLayout/width_0.png\" alt=\"layout_width=&quot;0dp&quot;\" title=\"0 dp\"></p>\n</li>\n<li><p><code>android:layout_width=&quot;match_parent&quot;</code>时：<br>组件大小=L+（L-（L+L+L））*权重比例，组件大小和权重成反比。<br>如果前面组件已经占满屏幕，则剩余组件无法获得空间，不可见。<br>各Button占的宽度：<br>每个Button的<code>layout_width</code>指定为<code>match_parent</code>，即表示每个Button指定大小为父组件宽度，即L。<br>Button1=L+(L-(L+L+L))*(1/6)，为4/6L；<br>Button2=L+(L-(L+L+L))*(2/6)，为2/6L；<br>Button3=L+L(L-(L+L+L))*(3/6)，为0。<br>所以Button1:Button2=2:1，Button3不可见。</p>\n<p> <img src=\"/2018/07/12/linearLayout/width_match.png\" alt=\"layout_width=&quot;match_parent&quot;\" title=\"match_parent\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p><code>android:layout_width=&quot;wrap_content&quot;</code>时：<br>组件大小=所需大小+(L-各组件所需大小和)*权重比例，剩余大小即(L-各组件所需大小和)为正，则为正比，否则为反比。<br>该情况和组件内容占用大小有关，所以布局上并不是很明显的比例关系，因为比例关系仅指剩余大小的比例：<br> 剩余大小为正，即屏幕空间足够，所占空间和权重成正比。<br> <img src=\"/2018/07/12/linearLayout/width_enough.png\" alt=\"layout_width=&quot;wrap_content&quot; enough\" title=\"wrap_content enough\"></p>\n<p> 剩余大小为负，即屏幕空间不足，所占空间和权重成反比，下面的图可能有点难看，希望想表达的意思到了。<br> <img src=\"/2018/07/12/linearLayout/width_less.png\" alt=\"layout_width=&quot;wrap_content&quot; less\" title=\"wrap_content less\"></p>\n</li>\n</ol>\n<p><code>LinearLayout</code>的<code>android:layout_weight</code>属性用起来很简单，但是如果想深入理解其原理，就需要参考源代码了。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;<code>LinearLayout</code>，很常用的一种布局，当在使用这种布局方式时，为了达到较好的屏幕适配效果，可以选择使用<code>android:layout_weight</code>属性。当为布局中的每个组件指定了大小和权重之后，我们的android系统如何计算各组件实际所占空间呢？<br></p>","more":"<br>贴个自己常用的计算方法：<br><strong>实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。</strong><p></p>\n<p>用一屏幕的大小减去所有组件大小的和，得到剩余大小，或理解为可分配空间，该值可为负。然后用我们给某个组件设定的值，加上其在剩余大小中按比例计算后的值，就是该组件最后的实际大小。<br>可用空间=屏幕大小-所有组件大小的和，<br>实际大小=指定大小+可用空间*权重比例，<br>所以最后为：<br>实际大小=指定大小+（屏幕大小-（所有组件大小的和））*权重比例。</p>\n<p>示例:<br>以<code>android:layout_width</code>为例，验证计算方式（屏幕宽度：L）<br>在<code>LinearLayout</code>中放置三个按钮，分别为Button1，Button2，Button3，<code>android:layout_height=&quot;wrap_content&quot;</code>均指定为包裹内容，每个Button的<code>android:layout_weight</code>分别为1，2，3。</p>\n<p>依据<code>android:layout_width</code>属性的设置，分三种情况：</p>\n<ol>\n<li><p><code>android:layout_width=&quot;0dp&quot;</code>时：<br>组件大小=0+（L-（0+0+0））*权重比例，组件大小和权重成正比。<br>各Button占的宽度：<br>Button1=0+(L-(0+0+0))*(1/6)，为1/6L；<br>Button2=0+(L-(0+0+0))*(2/6)，为2/6L；<br>Button3=0+(L-(0+0+0))*(3/6)，为3/6L。<br>所以Button1:Button2:Button3 = 1:2:3。</p>\n<p> <img src=\"/2018/07/12/linearLayout/width_0.png\" alt=\"layout_width=&quot;0dp&quot;\" title=\"0 dp\"></p>\n</li>\n<li><p><code>android:layout_width=&quot;match_parent&quot;</code>时：<br>组件大小=L+（L-（L+L+L））*权重比例，组件大小和权重成反比。<br>如果前面组件已经占满屏幕，则剩余组件无法获得空间，不可见。<br>各Button占的宽度：<br>每个Button的<code>layout_width</code>指定为<code>match_parent</code>，即表示每个Button指定大小为父组件宽度，即L。<br>Button1=L+(L-(L+L+L))*(1/6)，为4/6L；<br>Button2=L+(L-(L+L+L))*(2/6)，为2/6L；<br>Button3=L+L(L-(L+L+L))*(3/6)，为0。<br>所以Button1:Button2=2:1，Button3不可见。</p>\n<p> <img src=\"/2018/07/12/linearLayout/width_match.png\" alt=\"layout_width=&quot;match_parent&quot;\" title=\"match_parent\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p><code>android:layout_width=&quot;wrap_content&quot;</code>时：<br>组件大小=所需大小+(L-各组件所需大小和)*权重比例，剩余大小即(L-各组件所需大小和)为正，则为正比，否则为反比。<br>该情况和组件内容占用大小有关，所以布局上并不是很明显的比例关系，因为比例关系仅指剩余大小的比例：<br> 剩余大小为正，即屏幕空间足够，所占空间和权重成正比。<br> <img src=\"/2018/07/12/linearLayout/width_enough.png\" alt=\"layout_width=&quot;wrap_content&quot; enough\" title=\"wrap_content enough\"></p>\n<p> 剩余大小为负，即屏幕空间不足，所占空间和权重成反比，下面的图可能有点难看，希望想表达的意思到了。<br> <img src=\"/2018/07/12/linearLayout/width_less.png\" alt=\"layout_width=&quot;wrap_content&quot; less\" title=\"wrap_content less\"></p>\n</li>\n</ol>\n<p><code>LinearLayout</code>的<code>android:layout_weight</code>属性用起来很简单，但是如果想深入理解其原理，就需要参考源代码了。</p>"},{"title":"Android事件分发机制（一）","_content":"事件分发机制有点复杂，而且似乎笼罩着一层神秘的面纱。为了揭开它，决定进去源码里面看一看，并把过程记录下来，作为一份笔记。如果对大家理解事件分发机制有所帮助，那是再好不过的事情。首先，将稍微整理事件分发机制中，需要理清的几个问题，然后才开始看源码。\n<!--more-->\n\n# 关于事件分发的几个问题\n\n1. 为什么要进行事件分发？\n\n用户在Android系统屏幕上进行操作后，会有相应的事件产生。当产生事件的区域，有多个组件可以响应这个事件时，Android系统需要事件分发机制，来决定该事件传递给哪一个组件进行处理。\n\n2. 什么是事件分发？\n\n是指Android系统对用户行为产生的事件，进行传递处理的过程。\n\n3. 事件分发指的是什么事件？\n\n用户操作行为所产生的MotionEvent事件，具体可以是：ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_CANCEL等。\n\n4. 如何进行事件分发？\n\n采用责任链式的设计模式，事件层层传递，从上往下，再从下往上，寻找最终消费事件的组件，未找到，则将该次事件丢弃。\n\n# 事件分发详解\n\n事件分发的主体主要是ViewGroup和View，虽然ViewGroup也是继承自View，但是在事件的处理上ViewGroup和View所需要考虑的因素不同，处理过程有所不同，因为ViewGroup除了要考虑自己，还需要考虑其中的各个子View。至于Activity，理解了ViewGroup事件分发，Activity差不多也通了。所以，将事件分发分为两类进行分析：\n\n（1） ViewGroup的事件分发。\n\n（2） View的事件分发。\n\n### ViewGroup事件分发\n\nViewGroup事件分发主要涉及到以下三个方法：\n\n（1）public boolean dispatchTouchEvent(MotionEvent ev)。\n\n（2）public boolean onInterceptTouchEvent(MotionEvent ev)。\n\n（3）public boolean onTouchEvent(MotionEvent ev)。\n\n其中的核心方法是dispatchTouchEvent()，所以从这个方法开始分析。onInterceptTouchEvent()会在dispatchTouchEvent()的执行过程中被调用。onTouchEvent()是ViewGroup父类View的方法，只有当ViewGroup被当成View进行事件分发的时候，才会被调用。\n\nViewGroup被当成View进行事件分发的情况：\n\n（1）ViewGroup对事件进行了拦截。\n\n（2）事件发生在没有子View的区域。\n\n（3）ViewGroup中所有子View未消费事件，事件被回给了ViewGroup。\n\n开始贴源码，抓关键点进行分析与理解。我们先在源码ViewGroup.java类中，找到public boolean dispatchTouchEvent(MotionEvent ev)这个函数，按从上往下顺序看这个方法。\n\n1. 获取事件后，初始化相关变量，并判断是否进行了拦截\n找到dispatchTouchEvent()这个方法后，我们可以先看到下面这几行代码。本来想多贴一点，但是贴在这里密密麻麻，容易让人产生恐惧，而且找不到重点。所以，只贴关键的几行。后面也基本这样，每个重要的地方，只挑关键的几行代码贴出来，并加以说明。\n```python\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n```\n\t这两行是取消和清除上一次事件，并重置相关的变量。\n```python\n                intercepted = onInterceptTouchEvent(ev);\n```\n\t这一行主要在检测ViewGtoup有没有拦截事件。onInterceptTouchEvent()方法，依据它的执行结果，改变intercepted标志的值，这个值将作为事件是否分发给子View的依据。而onInterceptTouchEvent()方法里的代码如下：\n```python\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)\n                && ev.getAction() == MotionEvent.ACTION_DOWN\n                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)\n                && isOnScrollbarThumb(ev.getX(), ev.getY())) {\n            return true;\n        }\n        return false;\n    }\n```\n这几行是这个方法的所有代码，在开发的时候，可以重写这个方法，进行事件拦截。重写这个方法，让它返回true，表示不分发事件给子View，ViewGroup会被当成View进行事件分发。当intercepted为false时，它后面一大块和子View相关的代码才会被执行。\n\n2. 判断是否取消了这次事件\n```python\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n```\n3. 未被拦截，并且未取消\n```python\n            if (!canceled && !intercepted) {\n            // 省略\n            }\n```\n当if (!canceled && !intercepted)条件满足的时候，开始处理ViewGroup里面的组件。\n\n4. 拿到事件发生位置的点坐标\n```python\n            final float x = ev.getX(actionIndex);\n            final float y = ev.getY(actionIndex);\n```\n这个地方先拿到坐标，是为了后面判断子View有没有进行事件分发的条件。\n\n5. 收集子View\n```python\n            final ArrayList<View> preorderedList = buildTouchDispatchChildList();\n```\nbuildTouchDispatchChildList()这个方法，它返回了一个List集合。这个集合里面装着，按Z轴方向从小到大排序的所有子View，即Z值较大的子View放在这个List的后面。\n\n6. 遍历ViewGroup里的子View\n```python\n            for (int i = childrenCount - 1; i >= 0; i--) {\n            //省略\n            }\n```\n上一步已经拿到了一个按Z轴从小到大排好序的子View集合。这里遍历的时候是从后往前，所以，先处理List最后面的子View，即布局中盖在最上面的那个子View。\n\n7. 检测当前拿到的子View是不是处在事件产生的位置\n```python\n            if (!canViewReceivePointerEvents(child)\n                     || !isTransformedTouchPointInView(x, y, child, null)) {\n               ev.setTargetAccessibilityFocus(false);\n               continue;\n            }\n```\n先检测能否能接受事件，并且和前面拿到的点坐标结合，判断当前遍历到的这个View是否包含这个点坐标。不能接受事件或不包含事件的点坐标，continue，跳过后面的代码，开始下一次循环。如果子View包含这个坐标点的话，帮子View包装一下，赋值给newTouchTarget，然后break，跳出循环，不再处理剩下的子View。因为它表示当前View正在接收处理事件，不需要继续分发给其他View。\n\n那么，事件发生的点坐标在非子View和子View区域时，ViewGroup分别做了什么？\n\n（1）事件的点坐标在非子View区域\n遍历所有子View，发现它们都不在事件发生点的位置，for循环里后面的代码都不会执行。最终清空了一下装子View的List，跳出了if (!canceled && !intercepted)后面的语句块，而到了下面这里。\n```python\n            // Dispatch to touch targets.\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n            //省略\n            }\n```\nmFirstTouchTarget为空，表示没有子View能处理这个事件，而开始执行dispatchTransformedTouchEvent()方法，child的入参为null。\n其中关键的代码如下：\n```python\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        }\n```\n可以看到，child为空的时候，调用了super.dispatchTouchEvent()，即ViewGroup父类的dispatchTouchEvent()，而ViewGroup的父类是View。此时，ViewGroup被当成了一个View进行事件分发。\n\n（2）事件点坐标在子View区域\n事件点坐标在子View区域时，继续循环里面的代码：\n```python\n            if(dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            //省略\n            }\n```\n\n调用dispatchTransformedTouchEvent()方法后，会执行里面的下面这部分代码：\n```python\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n```\n其中child对象，就是我们当前处理的这个子View。人家有料，所以handled = child.dispatchTouchEvent(event)会执行，开始了它的事件分发，这里也涉及到了View的事件分发，后面再单独介绍。这个事件如果被这个子View消费了，事件传递结束，它下面的其他子View也就没什么事。因为dispatchTransformedTouchEvent()返回值为true的话，break，退出了for循环，后边的子View没有机会。如果返回值为false，那表示当前的活（事件）这个子View干不了，换下一个。如果事件点坐标位置的所有子View都不消费事件，也会执行如下代码：\n```python\n            // Dispatch to touch targets.\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            }\n```\n这时候和事件发生在ViewGroup的非子View区域时一样，执行了相同的代码块，把ViewGroup当成View来进行事件分发。值得注意的是，此时，这些子View已经进行过分发事件，即它们都会调用各自的dispatchTouchEvent()方法，只是都没有消费事件。\n\n\n\n\n\n","source":"_posts/Android_DispatchMotionEvent.md","raw":"---\ntitle: Android事件分发机制（一）\n---\n事件分发机制有点复杂，而且似乎笼罩着一层神秘的面纱。为了揭开它，决定进去源码里面看一看，并把过程记录下来，作为一份笔记。如果对大家理解事件分发机制有所帮助，那是再好不过的事情。首先，将稍微整理事件分发机制中，需要理清的几个问题，然后才开始看源码。\n<!--more-->\n\n# 关于事件分发的几个问题\n\n1. 为什么要进行事件分发？\n\n用户在Android系统屏幕上进行操作后，会有相应的事件产生。当产生事件的区域，有多个组件可以响应这个事件时，Android系统需要事件分发机制，来决定该事件传递给哪一个组件进行处理。\n\n2. 什么是事件分发？\n\n是指Android系统对用户行为产生的事件，进行传递处理的过程。\n\n3. 事件分发指的是什么事件？\n\n用户操作行为所产生的MotionEvent事件，具体可以是：ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_CANCEL等。\n\n4. 如何进行事件分发？\n\n采用责任链式的设计模式，事件层层传递，从上往下，再从下往上，寻找最终消费事件的组件，未找到，则将该次事件丢弃。\n\n# 事件分发详解\n\n事件分发的主体主要是ViewGroup和View，虽然ViewGroup也是继承自View，但是在事件的处理上ViewGroup和View所需要考虑的因素不同，处理过程有所不同，因为ViewGroup除了要考虑自己，还需要考虑其中的各个子View。至于Activity，理解了ViewGroup事件分发，Activity差不多也通了。所以，将事件分发分为两类进行分析：\n\n（1） ViewGroup的事件分发。\n\n（2） View的事件分发。\n\n### ViewGroup事件分发\n\nViewGroup事件分发主要涉及到以下三个方法：\n\n（1）public boolean dispatchTouchEvent(MotionEvent ev)。\n\n（2）public boolean onInterceptTouchEvent(MotionEvent ev)。\n\n（3）public boolean onTouchEvent(MotionEvent ev)。\n\n其中的核心方法是dispatchTouchEvent()，所以从这个方法开始分析。onInterceptTouchEvent()会在dispatchTouchEvent()的执行过程中被调用。onTouchEvent()是ViewGroup父类View的方法，只有当ViewGroup被当成View进行事件分发的时候，才会被调用。\n\nViewGroup被当成View进行事件分发的情况：\n\n（1）ViewGroup对事件进行了拦截。\n\n（2）事件发生在没有子View的区域。\n\n（3）ViewGroup中所有子View未消费事件，事件被回给了ViewGroup。\n\n开始贴源码，抓关键点进行分析与理解。我们先在源码ViewGroup.java类中，找到public boolean dispatchTouchEvent(MotionEvent ev)这个函数，按从上往下顺序看这个方法。\n\n1. 获取事件后，初始化相关变量，并判断是否进行了拦截\n找到dispatchTouchEvent()这个方法后，我们可以先看到下面这几行代码。本来想多贴一点，但是贴在这里密密麻麻，容易让人产生恐惧，而且找不到重点。所以，只贴关键的几行。后面也基本这样，每个重要的地方，只挑关键的几行代码贴出来，并加以说明。\n```python\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n```\n\t这两行是取消和清除上一次事件，并重置相关的变量。\n```python\n                intercepted = onInterceptTouchEvent(ev);\n```\n\t这一行主要在检测ViewGtoup有没有拦截事件。onInterceptTouchEvent()方法，依据它的执行结果，改变intercepted标志的值，这个值将作为事件是否分发给子View的依据。而onInterceptTouchEvent()方法里的代码如下：\n```python\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)\n                && ev.getAction() == MotionEvent.ACTION_DOWN\n                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)\n                && isOnScrollbarThumb(ev.getX(), ev.getY())) {\n            return true;\n        }\n        return false;\n    }\n```\n这几行是这个方法的所有代码，在开发的时候，可以重写这个方法，进行事件拦截。重写这个方法，让它返回true，表示不分发事件给子View，ViewGroup会被当成View进行事件分发。当intercepted为false时，它后面一大块和子View相关的代码才会被执行。\n\n2. 判断是否取消了这次事件\n```python\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n```\n3. 未被拦截，并且未取消\n```python\n            if (!canceled && !intercepted) {\n            // 省略\n            }\n```\n当if (!canceled && !intercepted)条件满足的时候，开始处理ViewGroup里面的组件。\n\n4. 拿到事件发生位置的点坐标\n```python\n            final float x = ev.getX(actionIndex);\n            final float y = ev.getY(actionIndex);\n```\n这个地方先拿到坐标，是为了后面判断子View有没有进行事件分发的条件。\n\n5. 收集子View\n```python\n            final ArrayList<View> preorderedList = buildTouchDispatchChildList();\n```\nbuildTouchDispatchChildList()这个方法，它返回了一个List集合。这个集合里面装着，按Z轴方向从小到大排序的所有子View，即Z值较大的子View放在这个List的后面。\n\n6. 遍历ViewGroup里的子View\n```python\n            for (int i = childrenCount - 1; i >= 0; i--) {\n            //省略\n            }\n```\n上一步已经拿到了一个按Z轴从小到大排好序的子View集合。这里遍历的时候是从后往前，所以，先处理List最后面的子View，即布局中盖在最上面的那个子View。\n\n7. 检测当前拿到的子View是不是处在事件产生的位置\n```python\n            if (!canViewReceivePointerEvents(child)\n                     || !isTransformedTouchPointInView(x, y, child, null)) {\n               ev.setTargetAccessibilityFocus(false);\n               continue;\n            }\n```\n先检测能否能接受事件，并且和前面拿到的点坐标结合，判断当前遍历到的这个View是否包含这个点坐标。不能接受事件或不包含事件的点坐标，continue，跳过后面的代码，开始下一次循环。如果子View包含这个坐标点的话，帮子View包装一下，赋值给newTouchTarget，然后break，跳出循环，不再处理剩下的子View。因为它表示当前View正在接收处理事件，不需要继续分发给其他View。\n\n那么，事件发生的点坐标在非子View和子View区域时，ViewGroup分别做了什么？\n\n（1）事件的点坐标在非子View区域\n遍历所有子View，发现它们都不在事件发生点的位置，for循环里后面的代码都不会执行。最终清空了一下装子View的List，跳出了if (!canceled && !intercepted)后面的语句块，而到了下面这里。\n```python\n            // Dispatch to touch targets.\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n            //省略\n            }\n```\nmFirstTouchTarget为空，表示没有子View能处理这个事件，而开始执行dispatchTransformedTouchEvent()方法，child的入参为null。\n其中关键的代码如下：\n```python\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        }\n```\n可以看到，child为空的时候，调用了super.dispatchTouchEvent()，即ViewGroup父类的dispatchTouchEvent()，而ViewGroup的父类是View。此时，ViewGroup被当成了一个View进行事件分发。\n\n（2）事件点坐标在子View区域\n事件点坐标在子View区域时，继续循环里面的代码：\n```python\n            if(dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            //省略\n            }\n```\n\n调用dispatchTransformedTouchEvent()方法后，会执行里面的下面这部分代码：\n```python\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n```\n其中child对象，就是我们当前处理的这个子View。人家有料，所以handled = child.dispatchTouchEvent(event)会执行，开始了它的事件分发，这里也涉及到了View的事件分发，后面再单独介绍。这个事件如果被这个子View消费了，事件传递结束，它下面的其他子View也就没什么事。因为dispatchTransformedTouchEvent()返回值为true的话，break，退出了for循环，后边的子View没有机会。如果返回值为false，那表示当前的活（事件）这个子View干不了，换下一个。如果事件点坐标位置的所有子View都不消费事件，也会执行如下代码：\n```python\n            // Dispatch to touch targets.\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            }\n```\n这时候和事件发生在ViewGroup的非子View区域时一样，执行了相同的代码块，把ViewGroup当成View来进行事件分发。值得注意的是，此时，这些子View已经进行过分发事件，即它们都会调用各自的dispatchTouchEvent()方法，只是都没有消费事件。\n\n\n\n\n\n","slug":"Android_DispatchMotionEvent","published":1,"date":"2018-08-02T10:34:19.714Z","updated":"2018-08-02T10:34:19.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdb40004idfsiwf4ej8f","content":"<p>事件分发机制有点复杂，而且似乎笼罩着一层神秘的面纱。为了揭开它，决定进去源码里面看一看，并把过程记录下来，作为一份笔记。如果对大家理解事件分发机制有所帮助，那是再好不过的事情。首先，将稍微整理事件分发机制中，需要理清的几个问题，然后才开始看源码。<br><a id=\"more\"></a></p>\n<h1 id=\"关于事件分发的几个问题\"><a href=\"#关于事件分发的几个问题\" class=\"headerlink\" title=\"关于事件分发的几个问题\"></a>关于事件分发的几个问题</h1><ol>\n<li>为什么要进行事件分发？</li>\n</ol>\n<p>用户在Android系统屏幕上进行操作后，会有相应的事件产生。当产生事件的区域，有多个组件可以响应这个事件时，Android系统需要事件分发机制，来决定该事件传递给哪一个组件进行处理。</p>\n<ol start=\"2\">\n<li>什么是事件分发？</li>\n</ol>\n<p>是指Android系统对用户行为产生的事件，进行传递处理的过程。</p>\n<ol start=\"3\">\n<li>事件分发指的是什么事件？</li>\n</ol>\n<p>用户操作行为所产生的MotionEvent事件，具体可以是：ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_CANCEL等。</p>\n<ol start=\"4\">\n<li>如何进行事件分发？</li>\n</ol>\n<p>采用责任链式的设计模式，事件层层传递，从上往下，再从下往上，寻找最终消费事件的组件，未找到，则将该次事件丢弃。</p>\n<h1 id=\"事件分发详解\"><a href=\"#事件分发详解\" class=\"headerlink\" title=\"事件分发详解\"></a>事件分发详解</h1><p>事件分发的主体主要是ViewGroup和View，虽然ViewGroup也是继承自View，但是在事件的处理上ViewGroup和View所需要考虑的因素不同，处理过程有所不同，因为ViewGroup除了要考虑自己，还需要考虑其中的各个子View。至于Activity，理解了ViewGroup事件分发，Activity差不多也通了。所以，将事件分发分为两类进行分析：</p>\n<p>（1） ViewGroup的事件分发。</p>\n<p>（2） View的事件分发。</p>\n<h3 id=\"ViewGroup事件分发\"><a href=\"#ViewGroup事件分发\" class=\"headerlink\" title=\"ViewGroup事件分发\"></a>ViewGroup事件分发</h3><p>ViewGroup事件分发主要涉及到以下三个方法：</p>\n<p>（1）public boolean dispatchTouchEvent(MotionEvent ev)。</p>\n<p>（2）public boolean onInterceptTouchEvent(MotionEvent ev)。</p>\n<p>（3）public boolean onTouchEvent(MotionEvent ev)。</p>\n<p>其中的核心方法是dispatchTouchEvent()，所以从这个方法开始分析。onInterceptTouchEvent()会在dispatchTouchEvent()的执行过程中被调用。onTouchEvent()是ViewGroup父类View的方法，只有当ViewGroup被当成View进行事件分发的时候，才会被调用。</p>\n<p>ViewGroup被当成View进行事件分发的情况：</p>\n<p>（1）ViewGroup对事件进行了拦截。</p>\n<p>（2）事件发生在没有子View的区域。</p>\n<p>（3）ViewGroup中所有子View未消费事件，事件被回给了ViewGroup。</p>\n<p>开始贴源码，抓关键点进行分析与理解。我们先在源码ViewGroup.java类中，找到public boolean dispatchTouchEvent(MotionEvent ev)这个函数，按从上往下顺序看这个方法。</p>\n<ol>\n<li><p>获取事件后，初始化相关变量，并判断是否进行了拦截<br>找到dispatchTouchEvent()这个方法后，我们可以先看到下面这几行代码。本来想多贴一点，但是贴在这里密密麻麻，容易让人产生恐惧，而且找不到重点。所以，只贴关键的几行。后面也基本这样，每个重要的地方，只挑关键的几行代码贴出来，并加以说明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">resetTouchState();</span><br></pre></td></tr></table></figure>\n<p> 这两行是取消和清除上一次事件，并重置相关的变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intercepted = onInterceptTouchEvent(ev);</span><br></pre></td></tr></table></figure>\n<p> 这一行主要在检测ViewGtoup有没有拦截事件。onInterceptTouchEvent()方法，依据它的执行结果，改变intercepted标志的值，这个值将作为事件是否分发给子View的依据。而onInterceptTouchEvent()方法里的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class=\"line\">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class=\"line\">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这几行是这个方法的所有代码，在开发的时候，可以重写这个方法，进行事件拦截。重写这个方法，让它返回true，表示不分发事件给子View，ViewGroup会被当成View进行事件分发。当intercepted为false时，它后面一大块和子View相关的代码才会被执行。</p>\n<ol start=\"2\">\n<li><p>判断是否取消了这次事件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Check <span class=\"keyword\">for</span> cancelation.</span><br><span class=\"line\">final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>未被拦截，并且未取消</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">// 省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当if (!canceled &amp;&amp; !intercepted)条件满足的时候，开始处理ViewGroup里面的组件。</p>\n<ol start=\"4\">\n<li>拿到事件发生位置的点坐标<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final float x = ev.getX(actionIndex);</span><br><span class=\"line\">final float y = ev.getY(actionIndex);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这个地方先拿到坐标，是为了后面判断子View有没有进行事件分发的条件。</p>\n<ol start=\"5\">\n<li>收集子View<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>buildTouchDispatchChildList()这个方法，它返回了一个List集合。这个集合里面装着，按Z轴方向从小到大排序的所有子View，即Z值较大的子View放在这个List的后面。</p>\n<ol start=\"6\">\n<li>遍历ViewGroup里的子View<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (int i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上一步已经拿到了一个按Z轴从小到大排好序的子View集合。这里遍历的时候是从后往前，所以，先处理List最后面的子View，即布局中盖在最上面的那个子View。</p>\n<ol start=\"7\">\n<li>检测当前拿到的子View是不是处在事件产生的位置<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canViewReceivePointerEvents(child)</span><br><span class=\"line\">         || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class=\"line\">   ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">   <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先检测能否能接受事件，并且和前面拿到的点坐标结合，判断当前遍历到的这个View是否包含这个点坐标。不能接受事件或不包含事件的点坐标，continue，跳过后面的代码，开始下一次循环。如果子View包含这个坐标点的话，帮子View包装一下，赋值给newTouchTarget，然后break，跳出循环，不再处理剩下的子View。因为它表示当前View正在接收处理事件，不需要继续分发给其他View。</p>\n<p>那么，事件发生的点坐标在非子View和子View区域时，ViewGroup分别做了什么？</p>\n<p>（1）事件的点坐标在非子View区域<br>遍历所有子View，发现它们都不在事件发生点的位置，for循环里后面的代码都不会执行。最终清空了一下装子View的List，跳出了if (!canceled &amp;&amp; !intercepted)后面的语句块，而到了下面这里。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Dispatch to touch targets.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">    // No touch targets so treat this <span class=\"keyword\">as</span> an ordinary view.</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mFirstTouchTarget为空，表示没有子View能处理这个事件，而开始执行dispatchTransformedTouchEvent()方法，child的入参为null。<br>其中关键的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (child == null) &#123;</span><br><span class=\"line\">    handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，child为空的时候，调用了super.dispatchTouchEvent()，即ViewGroup父类的dispatchTouchEvent()，而ViewGroup的父类是View。此时，ViewGroup被当成了一个View进行事件分发。</p>\n<p>（2）事件点坐标在子View区域<br>事件点坐标在子View区域时，继续循环里面的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用dispatchTransformedTouchEvent()方法后，会执行里面的下面这部分代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child == null) &#123;</span><br><span class=\"line\">        handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        final float offsetX = mScrollX - child.mLeft;</span><br><span class=\"line\">        final float offsetY = mScrollY - child.mTop;</span><br><span class=\"line\">        event.offsetLocation(offsetX, offsetY);</span><br><span class=\"line\"></span><br><span class=\"line\">        handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\"></span><br><span class=\"line\">        event.offsetLocation(-offsetX, -offsetY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中child对象，就是我们当前处理的这个子View。人家有料，所以handled = child.dispatchTouchEvent(event)会执行，开始了它的事件分发，这里也涉及到了View的事件分发，后面再单独介绍。这个事件如果被这个子View消费了，事件传递结束，它下面的其他子View也就没什么事。因为dispatchTransformedTouchEvent()返回值为true的话，break，退出了for循环，后边的子View没有机会。如果返回值为false，那表示当前的活（事件）这个子View干不了，换下一个。如果事件点坐标位置的所有子View都不消费事件，也会执行如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Dispatch to touch targets.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">    // No touch targets so treat this <span class=\"keyword\">as</span> an ordinary view.</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候和事件发生在ViewGroup的非子View区域时一样，执行了相同的代码块，把ViewGroup当成View来进行事件分发。值得注意的是，此时，这些子View已经进行过分发事件，即它们都会调用各自的dispatchTouchEvent()方法，只是都没有消费事件。</p>\n","site":{"data":{}},"excerpt":"<p>事件分发机制有点复杂，而且似乎笼罩着一层神秘的面纱。为了揭开它，决定进去源码里面看一看，并把过程记录下来，作为一份笔记。如果对大家理解事件分发机制有所帮助，那是再好不过的事情。首先，将稍微整理事件分发机制中，需要理清的几个问题，然后才开始看源码。<br></p>","more":"<p></p>\n<h1 id=\"关于事件分发的几个问题\"><a href=\"#关于事件分发的几个问题\" class=\"headerlink\" title=\"关于事件分发的几个问题\"></a>关于事件分发的几个问题</h1><ol>\n<li>为什么要进行事件分发？</li>\n</ol>\n<p>用户在Android系统屏幕上进行操作后，会有相应的事件产生。当产生事件的区域，有多个组件可以响应这个事件时，Android系统需要事件分发机制，来决定该事件传递给哪一个组件进行处理。</p>\n<ol start=\"2\">\n<li>什么是事件分发？</li>\n</ol>\n<p>是指Android系统对用户行为产生的事件，进行传递处理的过程。</p>\n<ol start=\"3\">\n<li>事件分发指的是什么事件？</li>\n</ol>\n<p>用户操作行为所产生的MotionEvent事件，具体可以是：ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_CANCEL等。</p>\n<ol start=\"4\">\n<li>如何进行事件分发？</li>\n</ol>\n<p>采用责任链式的设计模式，事件层层传递，从上往下，再从下往上，寻找最终消费事件的组件，未找到，则将该次事件丢弃。</p>\n<h1 id=\"事件分发详解\"><a href=\"#事件分发详解\" class=\"headerlink\" title=\"事件分发详解\"></a>事件分发详解</h1><p>事件分发的主体主要是ViewGroup和View，虽然ViewGroup也是继承自View，但是在事件的处理上ViewGroup和View所需要考虑的因素不同，处理过程有所不同，因为ViewGroup除了要考虑自己，还需要考虑其中的各个子View。至于Activity，理解了ViewGroup事件分发，Activity差不多也通了。所以，将事件分发分为两类进行分析：</p>\n<p>（1） ViewGroup的事件分发。</p>\n<p>（2） View的事件分发。</p>\n<h3 id=\"ViewGroup事件分发\"><a href=\"#ViewGroup事件分发\" class=\"headerlink\" title=\"ViewGroup事件分发\"></a>ViewGroup事件分发</h3><p>ViewGroup事件分发主要涉及到以下三个方法：</p>\n<p>（1）public boolean dispatchTouchEvent(MotionEvent ev)。</p>\n<p>（2）public boolean onInterceptTouchEvent(MotionEvent ev)。</p>\n<p>（3）public boolean onTouchEvent(MotionEvent ev)。</p>\n<p>其中的核心方法是dispatchTouchEvent()，所以从这个方法开始分析。onInterceptTouchEvent()会在dispatchTouchEvent()的执行过程中被调用。onTouchEvent()是ViewGroup父类View的方法，只有当ViewGroup被当成View进行事件分发的时候，才会被调用。</p>\n<p>ViewGroup被当成View进行事件分发的情况：</p>\n<p>（1）ViewGroup对事件进行了拦截。</p>\n<p>（2）事件发生在没有子View的区域。</p>\n<p>（3）ViewGroup中所有子View未消费事件，事件被回给了ViewGroup。</p>\n<p>开始贴源码，抓关键点进行分析与理解。我们先在源码ViewGroup.java类中，找到public boolean dispatchTouchEvent(MotionEvent ev)这个函数，按从上往下顺序看这个方法。</p>\n<ol>\n<li><p>获取事件后，初始化相关变量，并判断是否进行了拦截<br>找到dispatchTouchEvent()这个方法后，我们可以先看到下面这几行代码。本来想多贴一点，但是贴在这里密密麻麻，容易让人产生恐惧，而且找不到重点。所以，只贴关键的几行。后面也基本这样，每个重要的地方，只挑关键的几行代码贴出来，并加以说明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">resetTouchState();</span><br></pre></td></tr></table></figure>\n<p> 这两行是取消和清除上一次事件，并重置相关的变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intercepted = onInterceptTouchEvent(ev);</span><br></pre></td></tr></table></figure>\n<p> 这一行主要在检测ViewGtoup有没有拦截事件。onInterceptTouchEvent()方法，依据它的执行结果，改变intercepted标志的值，这个值将作为事件是否分发给子View的依据。而onInterceptTouchEvent()方法里的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class=\"line\">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class=\"line\">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这几行是这个方法的所有代码，在开发的时候，可以重写这个方法，进行事件拦截。重写这个方法，让它返回true，表示不分发事件给子View，ViewGroup会被当成View进行事件分发。当intercepted为false时，它后面一大块和子View相关的代码才会被执行。</p>\n<ol start=\"2\">\n<li><p>判断是否取消了这次事件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Check <span class=\"keyword\">for</span> cancelation.</span><br><span class=\"line\">final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>未被拦截，并且未取消</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">// 省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当if (!canceled &amp;&amp; !intercepted)条件满足的时候，开始处理ViewGroup里面的组件。</p>\n<ol start=\"4\">\n<li>拿到事件发生位置的点坐标<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final float x = ev.getX(actionIndex);</span><br><span class=\"line\">final float y = ev.getY(actionIndex);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这个地方先拿到坐标，是为了后面判断子View有没有进行事件分发的条件。</p>\n<ol start=\"5\">\n<li>收集子View<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>buildTouchDispatchChildList()这个方法，它返回了一个List集合。这个集合里面装着，按Z轴方向从小到大排序的所有子View，即Z值较大的子View放在这个List的后面。</p>\n<ol start=\"6\">\n<li>遍历ViewGroup里的子View<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (int i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上一步已经拿到了一个按Z轴从小到大排好序的子View集合。这里遍历的时候是从后往前，所以，先处理List最后面的子View，即布局中盖在最上面的那个子View。</p>\n<ol start=\"7\">\n<li>检测当前拿到的子View是不是处在事件产生的位置<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canViewReceivePointerEvents(child)</span><br><span class=\"line\">         || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class=\"line\">   ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">   <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先检测能否能接受事件，并且和前面拿到的点坐标结合，判断当前遍历到的这个View是否包含这个点坐标。不能接受事件或不包含事件的点坐标，continue，跳过后面的代码，开始下一次循环。如果子View包含这个坐标点的话，帮子View包装一下，赋值给newTouchTarget，然后break，跳出循环，不再处理剩下的子View。因为它表示当前View正在接收处理事件，不需要继续分发给其他View。</p>\n<p>那么，事件发生的点坐标在非子View和子View区域时，ViewGroup分别做了什么？</p>\n<p>（1）事件的点坐标在非子View区域<br>遍历所有子View，发现它们都不在事件发生点的位置，for循环里后面的代码都不会执行。最终清空了一下装子View的List，跳出了if (!canceled &amp;&amp; !intercepted)后面的语句块，而到了下面这里。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Dispatch to touch targets.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">    // No touch targets so treat this <span class=\"keyword\">as</span> an ordinary view.</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mFirstTouchTarget为空，表示没有子View能处理这个事件，而开始执行dispatchTransformedTouchEvent()方法，child的入参为null。<br>其中关键的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (child == null) &#123;</span><br><span class=\"line\">    handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，child为空的时候，调用了super.dispatchTouchEvent()，即ViewGroup父类的dispatchTouchEvent()，而ViewGroup的父类是View。此时，ViewGroup被当成了一个View进行事件分发。</p>\n<p>（2）事件点坐标在子View区域<br>事件点坐标在子View区域时，继续循环里面的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">//省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用dispatchTransformedTouchEvent()方法后，会执行里面的下面这部分代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child == null) &#123;</span><br><span class=\"line\">        handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        final float offsetX = mScrollX - child.mLeft;</span><br><span class=\"line\">        final float offsetY = mScrollY - child.mTop;</span><br><span class=\"line\">        event.offsetLocation(offsetX, offsetY);</span><br><span class=\"line\"></span><br><span class=\"line\">        handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\"></span><br><span class=\"line\">        event.offsetLocation(-offsetX, -offsetY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中child对象，就是我们当前处理的这个子View。人家有料，所以handled = child.dispatchTouchEvent(event)会执行，开始了它的事件分发，这里也涉及到了View的事件分发，后面再单独介绍。这个事件如果被这个子View消费了，事件传递结束，它下面的其他子View也就没什么事。因为dispatchTransformedTouchEvent()返回值为true的话，break，退出了for循环，后边的子View没有机会。如果返回值为false，那表示当前的活（事件）这个子View干不了，换下一个。如果事件点坐标位置的所有子View都不消费事件，也会执行如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Dispatch to touch targets.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">    // No touch targets so treat this <span class=\"keyword\">as</span> an ordinary view.</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候和事件发生在ViewGroup的非子View区域时一样，执行了相同的代码块，把ViewGroup当成View来进行事件分发。值得注意的是，此时，这些子View已经进行过分发事件，即它们都会调用各自的dispatchTouchEvent()方法，只是都没有消费事件。</p>"},{"title":"Android Framework层的JNI机制（一）","_content":"JNI（Java Native Interface）Java本地接口。最初对JNI的了解，仅仅停留在Java通过JNI可以实现对C/C++函数的调用。比如，首先在Java中写好native方法。然后在C或C++中文件中，定义一个对应的函数，在这个函数中，实现自己的代码或者调用其他的标准库。最后加载一下生成的动态库，便可以开始使用这个native方法。<!--more-->像是在照葫芦画瓢，知其然，不知其所以然。最近在看Framework层中JNI相关的代码，加上网上大咖的神贴，综合理解，先以Framework中Log为研究对象，分析JNI在其中的使用。\n\n# 概要\n+ **JNI机制基本要点**\n+ **Android中JNI的存在方式**\n+ **Framework层Log的JNI使用**\n\n# 一、JNI机制基本要点\n用过JNI的工程师，都接触过下面这些知识点：\n+ JavaVM：表示Java虚拟机。\n+ JNIEnv：表示JNI环境的上下文，例如注册、查找类、异常等。\n+ jclass：在JNI中表示的Java类。\n+ jmethodID：在JNI中表示的Java类中的方法。\n+ jfiledID：在JNI中表示IDEJava类中的属性。\n+ 线程：JNI中通过AttachCurrentThread和DetachCurrentThread方法，实现和Java线程的结合。\n\n它们都在一个叫jni.h的头文件头文件，这个头文件是JNI机制中很重要的一个头文件。\n源代码路径：`/libnativehelper/include/nativehelper/jni.h`。\n\n在libnativehelper目录下的源文件，编译后会生成一个libnativehelper.so的动态库。其实，jni.h是Android根据Java本地调用的标准写成的一个头文件，在它里面包括了基本类型（类型的映射），以及JavaVM，JNIEnv，jclass，jmethodID，jfiledID等数据结构的定义。\n\nJavaVM对应于jni.h中JNIInvokeInterface结构体，表示虚拟机。JNIEnv对应于JNINativeInterface结构体，表示JNI的环境。在JNI的使用过程中，所调用的功能大都来自JNINativeInterface结构体。例如，处理Java属性和方法的查找，Java属性的访问，Java方法的调用等功能。另外，在JNINativeInterface结构体中，涉及到的一个JNINativeMethod结构体，它表示在本地实现的一个方法，即native方法，后面进行JNI注册的时候会用到。\n\n# 二、Android中JNI的存在方式\nAndroid中JNI的存在方式主要分两种： 框架层和应用层的JNI使用。不对应用层的使用情况进行介绍，主要目的还是看看框架层里面的JNI。\n在Android框架中，JNI库是一些普通的本地动态库，被放置在目标系统的/system/lib目录中。\nJava框架层，最主要的JNI内容源代码路径为：`/frameworks/base/core/jni`。\n这里面的代码会生成一个libandroid_runtiem.so的动态库。接下来要分析的Log中JNI的使用，就在这个目录之中。\n\n# 三、Framework层Log相关\n1. **Java框架层的Log**\n在编程的时候，大家都用过Log，其实这个我们经常使用的Log工具，在Java框架层最终调用的是native方法。\n贴上源码的路径：`/frameworks/base/core/java/android/util/Log.java`。\n如果感兴趣，可以进去瞧一瞧。咱们以Log.java中的println_native()这个本地方法，进行分析。\n\n2. **Log的JNI实现**\nLog的JNI的实现是在一个叫`android_util_Log.cpp`的源文件中。\n源码路径：\n头文件：`/frameworks/base/core/jni/android_util_Log.h`。\n源文件：`/frameworks/base/core/jni/android_util_Log.cpp`。\n\n在android_util_Log.cpp源文件中，我们可以找到println_native的身影。\n```python\n/*\n * JNI registration.\n */\nstatic const JNINativeMethod gMethods[] = {\n    /* name, signature, funcPtr */\n    { \"isLoggable\",      \"(Ljava/lang/String;I)Z\", (void*) android_util_Log_isLoggable },\n    { \"println_native\",  \"(IILjava/lang/String;Ljava/lang/String;)I\", (void*) android_util_Log_println_native },\n    { \"logger_entry_max_payload_native\",  \"()I\", (void*) android_util_Log_logger_entry_max_payload_native },\n};\n```\nJNINativeMethod是前面提到的一个结构体，这个结构体表示一个实现的本地方法。这个结构体在jni.h文件中定义，内容如下：\n```python\ntypedef struct {\n    const char* name;\n    const char* signature;\n    void*       fnPtr;\n} JNINativeMethod;\n```\n它有三个指针变量，第一个是字符型指针，可以表示一个字符串，即native方法的名称；第二个也是字符型指针，同样可以表示一个字符串，代表这个native方法的参数和返回值（有特殊的表示方法）；第三个是一个未指定类型指针，表示一个函数指针，指向这个native方法对应的jni函数。\n\n有了对JNINativeMethod了解，就可以理解`println_native`在`android_util_Log.cpp`源文件中的含义了。其对应jni实现函数是`android_util_Log_println_native()`。在jni实现函数中，又调用了`__android_log_buf_write()`这个方法，`__android_log_buf_write`是本地框架层（非Java框架层）基础的C库之上，Android最底层的本地Log库。\nLog库的源码路径为：\n头文件：`system/core/include/cutils/log.h`。\n源文件：`system/core/liblog`。\n编译后会生成liblog.so动态库和liblog.a静态库。\n\n3. **JNI的注册**\n```python\nint register_android_util_Log(JNIEnv* env)\n{\n    jclass clazz = FindClassOrDie(env, \"android/util/Log\");\n\n    levels.verbose = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));\n    levels.debug = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));\n    levels.info = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));\n    levels.warn = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));\n    levels.error = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));\n    levels.assert = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));\n\n    return RegisterMethodsOrDie(env, \"android/util/Log\", gMethods, NELEM(gMethods));\n}\n```\n这是`android_util_Log.cpp`源文件中对jni的注册，可以看到RegisterMethodsOrDie()这个方法的调用，传入了我们前面看到的gMethods数组，进行JNI注册。到这里结束了吗？确实第一次看到这里的时候，以为就此结束了。然而，**是谁调用了register_android_util_Log()这个方法？在RegisterMethodsOrDie()这个函数里面又做了什么呢？**\n\n4. **register_android_util_Log()函数的调用**\n`register_android_util_Log()`这个方法只在`android_util_Log.cpp`源文件中进行定义，需要找到谁对它进行了调用，才好进一步理解Log的JNI的注册过程。Android源码环境有一个非常不错的方法，可以通过字符串，找到出现过的文件。\n指令：`cgrep 'register_android_util_Log'`\n类似于：`find . -type f -name \"*.cpp\" | xargs grep \"register_android_util_Log\"`\n通过结果可以发现一个AndoridRuntime.cpp，这是个什么鬼？只能说它很强，是系统运行时的工具类，为Android的运行提供支持。JNI的部分封装也在这个类中。\n源码路径：\n`/frameworks/base/include/android_runtime/AndroidRuntime.h`。\n`/frameworsk/base/core/jni/AndroidRuntime.cpp`。\n可以发现，它也是在/frameworsk/base/core/jni目录下，说明也是在libandroid_runtime.so动态库中。\n\n在AndroidRuntime.cpp源文件gRegJNI数组中，发现了`register_android_util_Log`方法。\n```python\nstatic const RegJNIRec gRegJNI[] = {\n    REG_JNI(register_com_android_internal_os_RuntimeInit),\n    REG_JNI(register_android_os_SystemClock),\n    REG_JNI(register_android_util_EventLog),\n    REG_JNI(register_android_util_Log),\n    REG_JNI(register_android_util_MemoryIntArray),\n    //省略\n}\n```\n然后，又在AndroidRuntime.cpp源文件的**AndroidRuntime::startReg()**这个方法中，使用了gRegJNI这个数组。\n```python\n/*\n * Register android native functions with the VM.\n */\n/*static*/ int AndroidRuntime::startReg(JNIEnv* env)\n{\n    ATRACE_NAME(\"RegisterAndroidNatives\");\n    /*\n     * This hook causes all future threads created in this process to be\n     * attached to the JavaVM.  (This needs to go away in favor of JNI\n     * Attach calls.)\n     */\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\n\n    ALOGV(\"--- registering native functions ---\\n\");\n\n    /*\n     * Every \"register\" function calls one or more things that return\n     * a local reference (e.g. FindClass).  Because we haven't really\n     * started the VM yet, they're all getting stored in the base frame\n     * and never released.  Use Push/Pop to manage the storage.\n     */\n    env->PushLocalFrame(200);\n\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\n        env->PopLocalFrame(NULL);\n        return -1;\n    }\n    env->PopLocalFrame(NULL);\n\n    //createJavaThread(\"fubar\", quickTest, (void*) \"hello\");\n\n    return 0;\n}\n```\n按源代码注释的意思是，这里在向虚拟机注册本地方法。同样在AndroidRuntime.cpp源文件中，AndroidRuntime::start()中又调用了AndroidRuntime::startReg()，到这里，需要继续往下看，就得找找**是谁调用了AndroidRuntime::start()**方法。然而，要想知道谁调用了它，已经涉及到zygote这一块的知识。\n\n5. **zygote**\nzygote是通过init进程读取init.rc启动的一个守护进程的名称。如果从最下面开始说，得再介绍一下Android启动流程的本地阶段，这一块，属于扩充了解。\n\nAndroid启动流程的本地阶段：\n+ BootLoader运行，Linux通用内容。\n+ Linux内核运行，Linux通用内容，通常是二进制形式代码形式存在。\n+ 内核加载根文件系统，Linux通用内容。\n+ init进程运行，用户空间的第一个进程。\n+ 运行init.rc脚本。\n+ 加载system和date文件系统。\n+ 运行各种服务，主要为各种守护进程。\n\n本地部分启动完成，形成一系列守护进程，其中名称为zygote的守护进程，将继续完成Java部分的初始化。\n\nJava部分的启动流程：\n+ 从本地可执行程序运行名为zygote的守护进程。\n+ zygote运行ZygoteInit（进入Java程序）。\n+ ZygoteInit运行SystemServer（Java类），并分裂出新的进程。\n+ SystemServer首先运行libandroid_servers.so库当中的初始化（进入本地程序）。\n+ 执行libanroid_servers.so当中的系统初始化。\n+ SystemServer中的Java初始化再次被调用（再入Java程序）。\n+ 建立ServerThread线程。\n+ ServerThread线程建立各个服务，然后进入循环。\n+ ActivityManagerService在启动结束发送相关信息。\n+ 各个Java应用程序运行。\n\n这些是引用资料书中的知识，想详细了解，可以看看《Android核心原理及系统级应用高效开发》或《深入理解Android系统》。回到我们的zygote进程，init.rc中包含了一个init.${ro.zygote}.rc。\ninit.rc和init.${ro.zygote}.rc源码路径：`/system/core/rootdir`。\n\n在init.zygote32.rc中，相关内容如下：\n```python\nservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    writepid /dev/cpuset/foreground/tasks\n```\n这个是Android系统中的特殊语法，它启动了一个名称为zygote的进程，也就是`/system/bin/app_process`这个可执行程序。\n源码路径为：`/frameworks/base/cmds/app_process`。\n在这个目录下，有一个`app_main.cpp`的源文件，其中相关的代码如下：\n```python\n// 省略\nif (zygote) {\n    runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n} else if (className) {\n    runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n} else {\n    fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n    app_usage();\n    LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n    return 10;\n}\n```\n在`app_main.cpp`源文件中，有一个AppRuntime的类，它继承了AndroidRuntime。runtime是AppRuntime类的一个实例，runtime.start()相当于调用了AndroidRuntime::start()这个方法，至此，前后就连接起来了。概括的说，系统启动zygote进程时，会调用AndroidRuntime::start()方法，接着调用AndroidRuntime::startReg()，然后调用到了`register_android_util_Log()`这个方法。剩下最后一个问题，`register_android_util_Log()`被调用后，在它方法体中的**RegisterMethodsOrDie()函数做了什么？**\n\n6. **RegisterMethodsOrDie()函数**\nRegisterMethodsOrDie()这个方法是`/frameworks/base/core/jni/core_jni_helpers.h`中声明的一个方法。\n```python\nstatic inline int RegisterMethodsOrDie(JNIEnv* env, const char* className,\n                                       const JNINativeMethod* gMethods, int numMethods) {\n    int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);\n    LOG_ALWAYS_FATAL_IF(res < 0, \"Unable to register native methods.\");\n    return res;\n}\n```\n在其中我们可以看到，其实又回到了AndroidRuntime这个类，调用了它的registerNativeMethods()方法，并最终调用了jniRegisterNativeMethods()进行本地方法的注册。而jniRegisterNativeMethods()是/libnativehelper/JNIHelp.cpp源文件中的方法，它里面内容为：\n```python\nextern \"C\" int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,\n    const JNINativeMethod* gMethods, int numMethods)\n{\n    JNIEnv* e = reinterpret_cast<JNIEnv*>(env);\n\n    ALOGV(\"Registering %s's %d native methods...\", className, numMethods);\n\n    scoped_local_ref<jclass> c(env, findClass(env, className));\n    if (c.get() == NULL) {\n        char* tmp;\n        const char* msg;\n        if (asprintf(&tmp,\n                     \"Native registration unable to find class '%s'; aborting...\",\n                     className) == -1) {\n            // Allocation failed, print default warning.\n            msg = \"Native registration unable to find class; aborting...\";\n        } else {\n            msg = tmp;\n        }\n        e->FatalError(msg);\n    }\n\n    if ((*env)->RegisterNatives(e, c.get(), gMethods, numMethods) < 0) {\n        char* tmp;\n        const char* msg;\n        if (asprintf(&tmp, \"RegisterNatives failed for '%s'; aborting...\", className) == -1) {\n            // Allocation failed, print default warning.\n            msg = \"RegisterNatives failed; aborting...\";\n        } else {\n            msg = tmp;\n        }\n        e->FatalError(msg);\n    }\n\n    return 0;\n}\n```\n\n这段代码可以看出，通过调用(*env)的RegisterNatives指针函数，进行了JNI注册。所以最后的动作是交给了JNINativeInterface结构体所表示的JNI环境执行。当在Java层调用native方法时，不需要依据native方法包和名称寻找对应的JNI函数。而是可以通过已经注册的映射关系，快速找到对应的JNI函数的指针，从而开始函数调用，大大提高执行效率。\n\n","source":"_posts/Framework_jni_1.md","raw":"---\ntitle: Android Framework层的JNI机制（一）\n---\nJNI（Java Native Interface）Java本地接口。最初对JNI的了解，仅仅停留在Java通过JNI可以实现对C/C++函数的调用。比如，首先在Java中写好native方法。然后在C或C++中文件中，定义一个对应的函数，在这个函数中，实现自己的代码或者调用其他的标准库。最后加载一下生成的动态库，便可以开始使用这个native方法。<!--more-->像是在照葫芦画瓢，知其然，不知其所以然。最近在看Framework层中JNI相关的代码，加上网上大咖的神贴，综合理解，先以Framework中Log为研究对象，分析JNI在其中的使用。\n\n# 概要\n+ **JNI机制基本要点**\n+ **Android中JNI的存在方式**\n+ **Framework层Log的JNI使用**\n\n# 一、JNI机制基本要点\n用过JNI的工程师，都接触过下面这些知识点：\n+ JavaVM：表示Java虚拟机。\n+ JNIEnv：表示JNI环境的上下文，例如注册、查找类、异常等。\n+ jclass：在JNI中表示的Java类。\n+ jmethodID：在JNI中表示的Java类中的方法。\n+ jfiledID：在JNI中表示IDEJava类中的属性。\n+ 线程：JNI中通过AttachCurrentThread和DetachCurrentThread方法，实现和Java线程的结合。\n\n它们都在一个叫jni.h的头文件头文件，这个头文件是JNI机制中很重要的一个头文件。\n源代码路径：`/libnativehelper/include/nativehelper/jni.h`。\n\n在libnativehelper目录下的源文件，编译后会生成一个libnativehelper.so的动态库。其实，jni.h是Android根据Java本地调用的标准写成的一个头文件，在它里面包括了基本类型（类型的映射），以及JavaVM，JNIEnv，jclass，jmethodID，jfiledID等数据结构的定义。\n\nJavaVM对应于jni.h中JNIInvokeInterface结构体，表示虚拟机。JNIEnv对应于JNINativeInterface结构体，表示JNI的环境。在JNI的使用过程中，所调用的功能大都来自JNINativeInterface结构体。例如，处理Java属性和方法的查找，Java属性的访问，Java方法的调用等功能。另外，在JNINativeInterface结构体中，涉及到的一个JNINativeMethod结构体，它表示在本地实现的一个方法，即native方法，后面进行JNI注册的时候会用到。\n\n# 二、Android中JNI的存在方式\nAndroid中JNI的存在方式主要分两种： 框架层和应用层的JNI使用。不对应用层的使用情况进行介绍，主要目的还是看看框架层里面的JNI。\n在Android框架中，JNI库是一些普通的本地动态库，被放置在目标系统的/system/lib目录中。\nJava框架层，最主要的JNI内容源代码路径为：`/frameworks/base/core/jni`。\n这里面的代码会生成一个libandroid_runtiem.so的动态库。接下来要分析的Log中JNI的使用，就在这个目录之中。\n\n# 三、Framework层Log相关\n1. **Java框架层的Log**\n在编程的时候，大家都用过Log，其实这个我们经常使用的Log工具，在Java框架层最终调用的是native方法。\n贴上源码的路径：`/frameworks/base/core/java/android/util/Log.java`。\n如果感兴趣，可以进去瞧一瞧。咱们以Log.java中的println_native()这个本地方法，进行分析。\n\n2. **Log的JNI实现**\nLog的JNI的实现是在一个叫`android_util_Log.cpp`的源文件中。\n源码路径：\n头文件：`/frameworks/base/core/jni/android_util_Log.h`。\n源文件：`/frameworks/base/core/jni/android_util_Log.cpp`。\n\n在android_util_Log.cpp源文件中，我们可以找到println_native的身影。\n```python\n/*\n * JNI registration.\n */\nstatic const JNINativeMethod gMethods[] = {\n    /* name, signature, funcPtr */\n    { \"isLoggable\",      \"(Ljava/lang/String;I)Z\", (void*) android_util_Log_isLoggable },\n    { \"println_native\",  \"(IILjava/lang/String;Ljava/lang/String;)I\", (void*) android_util_Log_println_native },\n    { \"logger_entry_max_payload_native\",  \"()I\", (void*) android_util_Log_logger_entry_max_payload_native },\n};\n```\nJNINativeMethod是前面提到的一个结构体，这个结构体表示一个实现的本地方法。这个结构体在jni.h文件中定义，内容如下：\n```python\ntypedef struct {\n    const char* name;\n    const char* signature;\n    void*       fnPtr;\n} JNINativeMethod;\n```\n它有三个指针变量，第一个是字符型指针，可以表示一个字符串，即native方法的名称；第二个也是字符型指针，同样可以表示一个字符串，代表这个native方法的参数和返回值（有特殊的表示方法）；第三个是一个未指定类型指针，表示一个函数指针，指向这个native方法对应的jni函数。\n\n有了对JNINativeMethod了解，就可以理解`println_native`在`android_util_Log.cpp`源文件中的含义了。其对应jni实现函数是`android_util_Log_println_native()`。在jni实现函数中，又调用了`__android_log_buf_write()`这个方法，`__android_log_buf_write`是本地框架层（非Java框架层）基础的C库之上，Android最底层的本地Log库。\nLog库的源码路径为：\n头文件：`system/core/include/cutils/log.h`。\n源文件：`system/core/liblog`。\n编译后会生成liblog.so动态库和liblog.a静态库。\n\n3. **JNI的注册**\n```python\nint register_android_util_Log(JNIEnv* env)\n{\n    jclass clazz = FindClassOrDie(env, \"android/util/Log\");\n\n    levels.verbose = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));\n    levels.debug = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));\n    levels.info = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));\n    levels.warn = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));\n    levels.error = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));\n    levels.assert = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));\n\n    return RegisterMethodsOrDie(env, \"android/util/Log\", gMethods, NELEM(gMethods));\n}\n```\n这是`android_util_Log.cpp`源文件中对jni的注册，可以看到RegisterMethodsOrDie()这个方法的调用，传入了我们前面看到的gMethods数组，进行JNI注册。到这里结束了吗？确实第一次看到这里的时候，以为就此结束了。然而，**是谁调用了register_android_util_Log()这个方法？在RegisterMethodsOrDie()这个函数里面又做了什么呢？**\n\n4. **register_android_util_Log()函数的调用**\n`register_android_util_Log()`这个方法只在`android_util_Log.cpp`源文件中进行定义，需要找到谁对它进行了调用，才好进一步理解Log的JNI的注册过程。Android源码环境有一个非常不错的方法，可以通过字符串，找到出现过的文件。\n指令：`cgrep 'register_android_util_Log'`\n类似于：`find . -type f -name \"*.cpp\" | xargs grep \"register_android_util_Log\"`\n通过结果可以发现一个AndoridRuntime.cpp，这是个什么鬼？只能说它很强，是系统运行时的工具类，为Android的运行提供支持。JNI的部分封装也在这个类中。\n源码路径：\n`/frameworks/base/include/android_runtime/AndroidRuntime.h`。\n`/frameworsk/base/core/jni/AndroidRuntime.cpp`。\n可以发现，它也是在/frameworsk/base/core/jni目录下，说明也是在libandroid_runtime.so动态库中。\n\n在AndroidRuntime.cpp源文件gRegJNI数组中，发现了`register_android_util_Log`方法。\n```python\nstatic const RegJNIRec gRegJNI[] = {\n    REG_JNI(register_com_android_internal_os_RuntimeInit),\n    REG_JNI(register_android_os_SystemClock),\n    REG_JNI(register_android_util_EventLog),\n    REG_JNI(register_android_util_Log),\n    REG_JNI(register_android_util_MemoryIntArray),\n    //省略\n}\n```\n然后，又在AndroidRuntime.cpp源文件的**AndroidRuntime::startReg()**这个方法中，使用了gRegJNI这个数组。\n```python\n/*\n * Register android native functions with the VM.\n */\n/*static*/ int AndroidRuntime::startReg(JNIEnv* env)\n{\n    ATRACE_NAME(\"RegisterAndroidNatives\");\n    /*\n     * This hook causes all future threads created in this process to be\n     * attached to the JavaVM.  (This needs to go away in favor of JNI\n     * Attach calls.)\n     */\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\n\n    ALOGV(\"--- registering native functions ---\\n\");\n\n    /*\n     * Every \"register\" function calls one or more things that return\n     * a local reference (e.g. FindClass).  Because we haven't really\n     * started the VM yet, they're all getting stored in the base frame\n     * and never released.  Use Push/Pop to manage the storage.\n     */\n    env->PushLocalFrame(200);\n\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\n        env->PopLocalFrame(NULL);\n        return -1;\n    }\n    env->PopLocalFrame(NULL);\n\n    //createJavaThread(\"fubar\", quickTest, (void*) \"hello\");\n\n    return 0;\n}\n```\n按源代码注释的意思是，这里在向虚拟机注册本地方法。同样在AndroidRuntime.cpp源文件中，AndroidRuntime::start()中又调用了AndroidRuntime::startReg()，到这里，需要继续往下看，就得找找**是谁调用了AndroidRuntime::start()**方法。然而，要想知道谁调用了它，已经涉及到zygote这一块的知识。\n\n5. **zygote**\nzygote是通过init进程读取init.rc启动的一个守护进程的名称。如果从最下面开始说，得再介绍一下Android启动流程的本地阶段，这一块，属于扩充了解。\n\nAndroid启动流程的本地阶段：\n+ BootLoader运行，Linux通用内容。\n+ Linux内核运行，Linux通用内容，通常是二进制形式代码形式存在。\n+ 内核加载根文件系统，Linux通用内容。\n+ init进程运行，用户空间的第一个进程。\n+ 运行init.rc脚本。\n+ 加载system和date文件系统。\n+ 运行各种服务，主要为各种守护进程。\n\n本地部分启动完成，形成一系列守护进程，其中名称为zygote的守护进程，将继续完成Java部分的初始化。\n\nJava部分的启动流程：\n+ 从本地可执行程序运行名为zygote的守护进程。\n+ zygote运行ZygoteInit（进入Java程序）。\n+ ZygoteInit运行SystemServer（Java类），并分裂出新的进程。\n+ SystemServer首先运行libandroid_servers.so库当中的初始化（进入本地程序）。\n+ 执行libanroid_servers.so当中的系统初始化。\n+ SystemServer中的Java初始化再次被调用（再入Java程序）。\n+ 建立ServerThread线程。\n+ ServerThread线程建立各个服务，然后进入循环。\n+ ActivityManagerService在启动结束发送相关信息。\n+ 各个Java应用程序运行。\n\n这些是引用资料书中的知识，想详细了解，可以看看《Android核心原理及系统级应用高效开发》或《深入理解Android系统》。回到我们的zygote进程，init.rc中包含了一个init.${ro.zygote}.rc。\ninit.rc和init.${ro.zygote}.rc源码路径：`/system/core/rootdir`。\n\n在init.zygote32.rc中，相关内容如下：\n```python\nservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    writepid /dev/cpuset/foreground/tasks\n```\n这个是Android系统中的特殊语法，它启动了一个名称为zygote的进程，也就是`/system/bin/app_process`这个可执行程序。\n源码路径为：`/frameworks/base/cmds/app_process`。\n在这个目录下，有一个`app_main.cpp`的源文件，其中相关的代码如下：\n```python\n// 省略\nif (zygote) {\n    runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n} else if (className) {\n    runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n} else {\n    fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n    app_usage();\n    LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n    return 10;\n}\n```\n在`app_main.cpp`源文件中，有一个AppRuntime的类，它继承了AndroidRuntime。runtime是AppRuntime类的一个实例，runtime.start()相当于调用了AndroidRuntime::start()这个方法，至此，前后就连接起来了。概括的说，系统启动zygote进程时，会调用AndroidRuntime::start()方法，接着调用AndroidRuntime::startReg()，然后调用到了`register_android_util_Log()`这个方法。剩下最后一个问题，`register_android_util_Log()`被调用后，在它方法体中的**RegisterMethodsOrDie()函数做了什么？**\n\n6. **RegisterMethodsOrDie()函数**\nRegisterMethodsOrDie()这个方法是`/frameworks/base/core/jni/core_jni_helpers.h`中声明的一个方法。\n```python\nstatic inline int RegisterMethodsOrDie(JNIEnv* env, const char* className,\n                                       const JNINativeMethod* gMethods, int numMethods) {\n    int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);\n    LOG_ALWAYS_FATAL_IF(res < 0, \"Unable to register native methods.\");\n    return res;\n}\n```\n在其中我们可以看到，其实又回到了AndroidRuntime这个类，调用了它的registerNativeMethods()方法，并最终调用了jniRegisterNativeMethods()进行本地方法的注册。而jniRegisterNativeMethods()是/libnativehelper/JNIHelp.cpp源文件中的方法，它里面内容为：\n```python\nextern \"C\" int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,\n    const JNINativeMethod* gMethods, int numMethods)\n{\n    JNIEnv* e = reinterpret_cast<JNIEnv*>(env);\n\n    ALOGV(\"Registering %s's %d native methods...\", className, numMethods);\n\n    scoped_local_ref<jclass> c(env, findClass(env, className));\n    if (c.get() == NULL) {\n        char* tmp;\n        const char* msg;\n        if (asprintf(&tmp,\n                     \"Native registration unable to find class '%s'; aborting...\",\n                     className) == -1) {\n            // Allocation failed, print default warning.\n            msg = \"Native registration unable to find class; aborting...\";\n        } else {\n            msg = tmp;\n        }\n        e->FatalError(msg);\n    }\n\n    if ((*env)->RegisterNatives(e, c.get(), gMethods, numMethods) < 0) {\n        char* tmp;\n        const char* msg;\n        if (asprintf(&tmp, \"RegisterNatives failed for '%s'; aborting...\", className) == -1) {\n            // Allocation failed, print default warning.\n            msg = \"RegisterNatives failed; aborting...\";\n        } else {\n            msg = tmp;\n        }\n        e->FatalError(msg);\n    }\n\n    return 0;\n}\n```\n\n这段代码可以看出，通过调用(*env)的RegisterNatives指针函数，进行了JNI注册。所以最后的动作是交给了JNINativeInterface结构体所表示的JNI环境执行。当在Java层调用native方法时，不需要依据native方法包和名称寻找对应的JNI函数。而是可以通过已经注册的映射关系，快速找到对应的JNI函数的指针，从而开始函数调用，大大提高执行效率。\n\n","slug":"Framework_jni_1","published":1,"date":"2018-09-03T03:58:00.173Z","updated":"2018-09-03T03:58:00.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdb50005idfsk9ltqftd","content":"<p>JNI（Java Native Interface）Java本地接口。最初对JNI的了解，仅仅停留在Java通过JNI可以实现对C/C++函数的调用。比如，首先在Java中写好native方法。然后在C或C++中文件中，定义一个对应的函数，在这个函数中，实现自己的代码或者调用其他的标准库。最后加载一下生成的动态库，便可以开始使用这个native方法。<a id=\"more\"></a>像是在照葫芦画瓢，知其然，不知其所以然。最近在看Framework层中JNI相关的代码，加上网上大咖的神贴，综合理解，先以Framework中Log为研究对象，分析JNI在其中的使用。</p>\n<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><ul>\n<li><strong>JNI机制基本要点</strong></li>\n<li><strong>Android中JNI的存在方式</strong></li>\n<li><strong>Framework层Log的JNI使用</strong></li>\n</ul>\n<h1 id=\"一、JNI机制基本要点\"><a href=\"#一、JNI机制基本要点\" class=\"headerlink\" title=\"一、JNI机制基本要点\"></a>一、JNI机制基本要点</h1><p>用过JNI的工程师，都接触过下面这些知识点：</p>\n<ul>\n<li>JavaVM：表示Java虚拟机。</li>\n<li>JNIEnv：表示JNI环境的上下文，例如注册、查找类、异常等。</li>\n<li>jclass：在JNI中表示的Java类。</li>\n<li>jmethodID：在JNI中表示的Java类中的方法。</li>\n<li>jfiledID：在JNI中表示IDEJava类中的属性。</li>\n<li>线程：JNI中通过AttachCurrentThread和DetachCurrentThread方法，实现和Java线程的结合。</li>\n</ul>\n<p>它们都在一个叫jni.h的头文件头文件，这个头文件是JNI机制中很重要的一个头文件。<br>源代码路径：<code>/libnativehelper/include/nativehelper/jni.h</code>。</p>\n<p>在libnativehelper目录下的源文件，编译后会生成一个libnativehelper.so的动态库。其实，jni.h是Android根据Java本地调用的标准写成的一个头文件，在它里面包括了基本类型（类型的映射），以及JavaVM，JNIEnv，jclass，jmethodID，jfiledID等数据结构的定义。</p>\n<p>JavaVM对应于jni.h中JNIInvokeInterface结构体，表示虚拟机。JNIEnv对应于JNINativeInterface结构体，表示JNI的环境。在JNI的使用过程中，所调用的功能大都来自JNINativeInterface结构体。例如，处理Java属性和方法的查找，Java属性的访问，Java方法的调用等功能。另外，在JNINativeInterface结构体中，涉及到的一个JNINativeMethod结构体，它表示在本地实现的一个方法，即native方法，后面进行JNI注册的时候会用到。</p>\n<h1 id=\"二、Android中JNI的存在方式\"><a href=\"#二、Android中JNI的存在方式\" class=\"headerlink\" title=\"二、Android中JNI的存在方式\"></a>二、Android中JNI的存在方式</h1><p>Android中JNI的存在方式主要分两种： 框架层和应用层的JNI使用。不对应用层的使用情况进行介绍，主要目的还是看看框架层里面的JNI。<br>在Android框架中，JNI库是一些普通的本地动态库，被放置在目标系统的/system/lib目录中。<br>Java框架层，最主要的JNI内容源代码路径为：<code>/frameworks/base/core/jni</code>。<br>这里面的代码会生成一个libandroid_runtiem.so的动态库。接下来要分析的Log中JNI的使用，就在这个目录之中。</p>\n<h1 id=\"三、Framework层Log相关\"><a href=\"#三、Framework层Log相关\" class=\"headerlink\" title=\"三、Framework层Log相关\"></a>三、Framework层Log相关</h1><ol>\n<li><p><strong>Java框架层的Log</strong><br>在编程的时候，大家都用过Log，其实这个我们经常使用的Log工具，在Java框架层最终调用的是native方法。<br>贴上源码的路径：<code>/frameworks/base/core/java/android/util/Log.java</code>。<br>如果感兴趣，可以进去瞧一瞧。咱们以Log.java中的println_native()这个本地方法，进行分析。</p>\n</li>\n<li><p><strong>Log的JNI实现</strong><br>Log的JNI的实现是在一个叫<code>android_util_Log.cpp</code>的源文件中。<br>源码路径：<br>头文件：<code>/frameworks/base/core/jni/android_util_Log.h</code>。<br>源文件：<code>/frameworks/base/core/jni/android_util_Log.cpp</code>。</p>\n</li>\n</ol>\n<p>在android_util_Log.cpp源文件中，我们可以找到println_native的身影。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * JNI registration.</span><br><span class=\"line\"> */</span><br><span class=\"line\">static const JNINativeMethod gMethods[] = &#123;</span><br><span class=\"line\">    /* name, signature, funcPtr */</span><br><span class=\"line\">    &#123; <span class=\"string\">\"isLoggable\"</span>,      <span class=\"string\">\"(Ljava/lang/String;I)Z\"</span>, (void*) android_util_Log_isLoggable &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"println_native\"</span>,  <span class=\"string\">\"(IILjava/lang/String;Ljava/lang/String;)I\"</span>, (void*) android_util_Log_println_native &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"logger_entry_max_payload_native\"</span>,  <span class=\"string\">\"()I\"</span>, (void*) android_util_Log_logger_entry_max_payload_native &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>JNINativeMethod是前面提到的一个结构体，这个结构体表示一个实现的本地方法。这个结构体在jni.h文件中定义，内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    const char* name;</span><br><span class=\"line\">    const char* signature;</span><br><span class=\"line\">    void*       fnPtr;</span><br><span class=\"line\">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p>\n<p>它有三个指针变量，第一个是字符型指针，可以表示一个字符串，即native方法的名称；第二个也是字符型指针，同样可以表示一个字符串，代表这个native方法的参数和返回值（有特殊的表示方法）；第三个是一个未指定类型指针，表示一个函数指针，指向这个native方法对应的jni函数。</p>\n<p>有了对JNINativeMethod了解，就可以理解<code>println_native</code>在<code>android_util_Log.cpp</code>源文件中的含义了。其对应jni实现函数是<code>android_util_Log_println_native()</code>。在jni实现函数中，又调用了<code>__android_log_buf_write()</code>这个方法，<code>__android_log_buf_write</code>是本地框架层（非Java框架层）基础的C库之上，Android最底层的本地Log库。<br>Log库的源码路径为：<br>头文件：<code>system/core/include/cutils/log.h</code>。<br>源文件：<code>system/core/liblog</code>。<br>编译后会生成liblog.so动态库和liblog.a静态库。</p>\n<ol start=\"3\">\n<li><strong>JNI的注册</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int register_android_util_Log(JNIEnv* env)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    jclass clazz = FindClassOrDie(env, <span class=\"string\">\"android/util/Log\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    levels.verbose = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));</span><br><span class=\"line\">    levels.debug = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));</span><br><span class=\"line\">    levels.info = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));</span><br><span class=\"line\">    levels.warn = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));</span><br><span class=\"line\">    levels.error = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));</span><br><span class=\"line\">    levels.assert = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> RegisterMethodsOrDie(env, <span class=\"string\">\"android/util/Log\"</span>, gMethods, NELEM(gMethods));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这是<code>android_util_Log.cpp</code>源文件中对jni的注册，可以看到RegisterMethodsOrDie()这个方法的调用，传入了我们前面看到的gMethods数组，进行JNI注册。到这里结束了吗？确实第一次看到这里的时候，以为就此结束了。然而，<strong>是谁调用了register_android_util_Log()这个方法？在RegisterMethodsOrDie()这个函数里面又做了什么呢？</strong></p>\n<ol start=\"4\">\n<li><strong>register_android_util_Log()函数的调用</strong><br><code>register_android_util_Log()</code>这个方法只在<code>android_util_Log.cpp</code>源文件中进行定义，需要找到谁对它进行了调用，才好进一步理解Log的JNI的注册过程。Android源码环境有一个非常不错的方法，可以通过字符串，找到出现过的文件。<br>指令：<code>cgrep &#39;register_android_util_Log&#39;</code><br>类似于：<code>find . -type f -name &quot;*.cpp&quot; | xargs grep &quot;register_android_util_Log&quot;</code><br>通过结果可以发现一个AndoridRuntime.cpp，这是个什么鬼？只能说它很强，是系统运行时的工具类，为Android的运行提供支持。JNI的部分封装也在这个类中。<br>源码路径：<br><code>/frameworks/base/include/android_runtime/AndroidRuntime.h</code>。<br><code>/frameworsk/base/core/jni/AndroidRuntime.cpp</code>。<br>可以发现，它也是在/frameworsk/base/core/jni目录下，说明也是在libandroid_runtime.so动态库中。</li>\n</ol>\n<p>在AndroidRuntime.cpp源文件gRegJNI数组中，发现了<code>register_android_util_Log</code>方法。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const RegJNIRec gRegJNI[] = &#123;</span><br><span class=\"line\">    REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class=\"line\">    REG_JNI(register_android_os_SystemClock),</span><br><span class=\"line\">    REG_JNI(register_android_util_EventLog),</span><br><span class=\"line\">    REG_JNI(register_android_util_Log),</span><br><span class=\"line\">    REG_JNI(register_android_util_MemoryIntArray),</span><br><span class=\"line\">    //省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，又在AndroidRuntime.cpp源文件的<strong>AndroidRuntime::startReg()</strong>这个方法中，使用了gRegJNI这个数组。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * Register android native functions <span class=\"keyword\">with</span> the VM.</span><br><span class=\"line\"> */</span><br><span class=\"line\">/*static*/ int AndroidRuntime::startReg(JNIEnv* env)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ATRACE_NAME(<span class=\"string\">\"RegisterAndroidNatives\"</span>);</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * This hook causes all future threads created <span class=\"keyword\">in</span> this process to be</span><br><span class=\"line\">     * attached to the JavaVM.  (This needs to go away <span class=\"keyword\">in</span> favor of JNI</span><br><span class=\"line\">     * Attach calls.)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class=\"line\"></span><br><span class=\"line\">    ALOGV(<span class=\"string\">\"--- registering native functions ---\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Every <span class=\"string\">\"register\"</span> function calls one <span class=\"keyword\">or</span> more things that <span class=\"keyword\">return</span></span><br><span class=\"line\">     * a local reference (e.g. FindClass).  Because we haven<span class=\"string\">'t really</span></span><br><span class=\"line\"><span class=\"string\">     * started the VM yet, they'</span>re all getting stored <span class=\"keyword\">in</span> the base frame</span><br><span class=\"line\">     * <span class=\"keyword\">and</span> never released.  Use Push/Pop to manage the storage.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    env-&gt;PushLocalFrame(200);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        env-&gt;PopLocalFrame(NULL);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    env-&gt;PopLocalFrame(NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    //createJavaThread(<span class=\"string\">\"fubar\"</span>, quickTest, (void*) <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按源代码注释的意思是，这里在向虚拟机注册本地方法。同样在AndroidRuntime.cpp源文件中，AndroidRuntime::start()中又调用了AndroidRuntime::startReg()，到这里，需要继续往下看，就得找找<strong>是谁调用了AndroidRuntime::start()</strong>方法。然而，要想知道谁调用了它，已经涉及到zygote这一块的知识。</p>\n<ol start=\"5\">\n<li><strong>zygote</strong><br>zygote是通过init进程读取init.rc启动的一个守护进程的名称。如果从最下面开始说，得再介绍一下Android启动流程的本地阶段，这一块，属于扩充了解。</li>\n</ol>\n<p>Android启动流程的本地阶段：</p>\n<ul>\n<li>BootLoader运行，Linux通用内容。</li>\n<li>Linux内核运行，Linux通用内容，通常是二进制形式代码形式存在。</li>\n<li>内核加载根文件系统，Linux通用内容。</li>\n<li>init进程运行，用户空间的第一个进程。</li>\n<li>运行init.rc脚本。</li>\n<li>加载system和date文件系统。</li>\n<li>运行各种服务，主要为各种守护进程。</li>\n</ul>\n<p>本地部分启动完成，形成一系列守护进程，其中名称为zygote的守护进程，将继续完成Java部分的初始化。</p>\n<p>Java部分的启动流程：</p>\n<ul>\n<li>从本地可执行程序运行名为zygote的守护进程。</li>\n<li>zygote运行ZygoteInit（进入Java程序）。</li>\n<li>ZygoteInit运行SystemServer（Java类），并分裂出新的进程。</li>\n<li>SystemServer首先运行libandroid_servers.so库当中的初始化（进入本地程序）。</li>\n<li>执行libanroid_servers.so当中的系统初始化。</li>\n<li>SystemServer中的Java初始化再次被调用（再入Java程序）。</li>\n<li>建立ServerThread线程。</li>\n<li>ServerThread线程建立各个服务，然后进入循环。</li>\n<li>ActivityManagerService在启动结束发送相关信息。</li>\n<li>各个Java应用程序运行。</li>\n</ul>\n<p>这些是引用资料书中的知识，想详细了解，可以看看《Android核心原理及系统级应用高效开发》或《深入理解Android系统》。回到我们的zygote进程，init.rc中包含了一个init.${ro.zygote}.rc。<br>init.rc和init.${ro.zygote}.rc源码路径：<code>/system/core/rootdir</code>。</p>\n<p>在init.zygote32.rc中，相关内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">main</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">socket</span> <span class=\"title\">zygote</span> <span class=\"title\">stream</span> 660 <span class=\"title\">root</span> <span class=\"title\">system</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">write</span> /<span class=\"title\">sys</span>/<span class=\"title\">android_power</span>/<span class=\"title\">request_state</span> <span class=\"title\">wake</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">write</span> /<span class=\"title\">sys</span>/<span class=\"title\">power</span>/<span class=\"title\">state</span> <span class=\"title\">on</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">audioserver</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">cameraserver</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">media</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">netd</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">writepid</span> /<span class=\"title\">dev</span>/<span class=\"title\">cpuset</span>/<span class=\"title\">foreground</span>/<span class=\"title\">tasks</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这个是Android系统中的特殊语法，它启动了一个名称为zygote的进程，也就是<code>/system/bin/app_process</code>这个可执行程序。<br>源码路径为：<code>/frameworks/base/cmds/app_process</code>。<br>在这个目录下，有一个<code>app_main.cpp</code>的源文件，其中相关的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 省略</span><br><span class=\"line\"><span class=\"keyword\">if</span> (zygote) &#123;</span><br><span class=\"line\">    runtime.start(<span class=\"string\">\"com.android.internal.os.ZygoteInit\"</span>, args, zygote);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className) &#123;</span><br><span class=\"line\">    runtime.start(<span class=\"string\">\"com.android.internal.os.RuntimeInit\"</span>, args, zygote);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fprintf(stderr, <span class=\"string\">\"Error: no class name or --zygote supplied.\\n\"</span>);</span><br><span class=\"line\">    app_usage();</span><br><span class=\"line\">    LOG_ALWAYS_FATAL(<span class=\"string\">\"app_process: no class name or --zygote supplied.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>app_main.cpp</code>源文件中，有一个AppRuntime的类，它继承了AndroidRuntime。runtime是AppRuntime类的一个实例，runtime.start()相当于调用了AndroidRuntime::start()这个方法，至此，前后就连接起来了。概括的说，系统启动zygote进程时，会调用AndroidRuntime::start()方法，接着调用AndroidRuntime::startReg()，然后调用到了<code>register_android_util_Log()</code>这个方法。剩下最后一个问题，<code>register_android_util_Log()</code>被调用后，在它方法体中的<strong>RegisterMethodsOrDie()函数做了什么？</strong></p>\n<ol start=\"6\">\n<li><strong>RegisterMethodsOrDie()函数</strong><br>RegisterMethodsOrDie()这个方法是<code>/frameworks/base/core/jni/core_jni_helpers.h</code>中声明的一个方法。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className,</span><br><span class=\"line\">                                       const JNINativeMethod* gMethods, int numMethods) &#123;</span><br><span class=\"line\">    int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(res &lt; <span class=\"number\">0</span>, <span class=\"string\">\"Unable to register native methods.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在其中我们可以看到，其实又回到了AndroidRuntime这个类，调用了它的registerNativeMethods()方法，并最终调用了jniRegisterNativeMethods()进行本地方法的注册。而jniRegisterNativeMethods()是/libnativehelper/JNIHelp.cpp源文件中的方法，它里面内容为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern <span class=\"string\">\"C\"</span> int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,</span><br><span class=\"line\">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class=\"line\"></span><br><span class=\"line\">    ALOGV(<span class=\"string\">\"Registering %s's %d native methods...\"</span>, className, numMethods);</span><br><span class=\"line\"></span><br><span class=\"line\">    scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c.get() == NULL) &#123;</span><br><span class=\"line\">        char* tmp;</span><br><span class=\"line\">        const char* msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asprintf(&amp;tmp,</span><br><span class=\"line\">                     <span class=\"string\">\"Native registration unable to find class '%s'; aborting...\"</span>,</span><br><span class=\"line\">                     className) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            // Allocation failed, <span class=\"keyword\">print</span> default warning.</span><br><span class=\"line\">            msg = <span class=\"string\">\"Native registration unable to find class; aborting...\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e-&gt;FatalError(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) &#123;</span><br><span class=\"line\">        char* tmp;</span><br><span class=\"line\">        const char* msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asprintf(&amp;tmp, <span class=\"string\">\"RegisterNatives failed for '%s'; aborting...\"</span>, className) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            // Allocation failed, <span class=\"keyword\">print</span> default warning.</span><br><span class=\"line\">            msg = <span class=\"string\">\"RegisterNatives failed; aborting...\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e-&gt;FatalError(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码可以看出，通过调用(*env)的RegisterNatives指针函数，进行了JNI注册。所以最后的动作是交给了JNINativeInterface结构体所表示的JNI环境执行。当在Java层调用native方法时，不需要依据native方法包和名称寻找对应的JNI函数。而是可以通过已经注册的映射关系，快速找到对应的JNI函数的指针，从而开始函数调用，大大提高执行效率。</p>\n","site":{"data":{}},"excerpt":"<p>JNI（Java Native Interface）Java本地接口。最初对JNI的了解，仅仅停留在Java通过JNI可以实现对C/C++函数的调用。比如，首先在Java中写好native方法。然后在C或C++中文件中，定义一个对应的函数，在这个函数中，实现自己的代码或者调用其他的标准库。最后加载一下生成的动态库，便可以开始使用这个native方法。</p>","more":"像是在照葫芦画瓢，知其然，不知其所以然。最近在看Framework层中JNI相关的代码，加上网上大咖的神贴，综合理解，先以Framework中Log为研究对象，分析JNI在其中的使用。<p></p>\n<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><ul>\n<li><strong>JNI机制基本要点</strong></li>\n<li><strong>Android中JNI的存在方式</strong></li>\n<li><strong>Framework层Log的JNI使用</strong></li>\n</ul>\n<h1 id=\"一、JNI机制基本要点\"><a href=\"#一、JNI机制基本要点\" class=\"headerlink\" title=\"一、JNI机制基本要点\"></a>一、JNI机制基本要点</h1><p>用过JNI的工程师，都接触过下面这些知识点：</p>\n<ul>\n<li>JavaVM：表示Java虚拟机。</li>\n<li>JNIEnv：表示JNI环境的上下文，例如注册、查找类、异常等。</li>\n<li>jclass：在JNI中表示的Java类。</li>\n<li>jmethodID：在JNI中表示的Java类中的方法。</li>\n<li>jfiledID：在JNI中表示IDEJava类中的属性。</li>\n<li>线程：JNI中通过AttachCurrentThread和DetachCurrentThread方法，实现和Java线程的结合。</li>\n</ul>\n<p>它们都在一个叫jni.h的头文件头文件，这个头文件是JNI机制中很重要的一个头文件。<br>源代码路径：<code>/libnativehelper/include/nativehelper/jni.h</code>。</p>\n<p>在libnativehelper目录下的源文件，编译后会生成一个libnativehelper.so的动态库。其实，jni.h是Android根据Java本地调用的标准写成的一个头文件，在它里面包括了基本类型（类型的映射），以及JavaVM，JNIEnv，jclass，jmethodID，jfiledID等数据结构的定义。</p>\n<p>JavaVM对应于jni.h中JNIInvokeInterface结构体，表示虚拟机。JNIEnv对应于JNINativeInterface结构体，表示JNI的环境。在JNI的使用过程中，所调用的功能大都来自JNINativeInterface结构体。例如，处理Java属性和方法的查找，Java属性的访问，Java方法的调用等功能。另外，在JNINativeInterface结构体中，涉及到的一个JNINativeMethod结构体，它表示在本地实现的一个方法，即native方法，后面进行JNI注册的时候会用到。</p>\n<h1 id=\"二、Android中JNI的存在方式\"><a href=\"#二、Android中JNI的存在方式\" class=\"headerlink\" title=\"二、Android中JNI的存在方式\"></a>二、Android中JNI的存在方式</h1><p>Android中JNI的存在方式主要分两种： 框架层和应用层的JNI使用。不对应用层的使用情况进行介绍，主要目的还是看看框架层里面的JNI。<br>在Android框架中，JNI库是一些普通的本地动态库，被放置在目标系统的/system/lib目录中。<br>Java框架层，最主要的JNI内容源代码路径为：<code>/frameworks/base/core/jni</code>。<br>这里面的代码会生成一个libandroid_runtiem.so的动态库。接下来要分析的Log中JNI的使用，就在这个目录之中。</p>\n<h1 id=\"三、Framework层Log相关\"><a href=\"#三、Framework层Log相关\" class=\"headerlink\" title=\"三、Framework层Log相关\"></a>三、Framework层Log相关</h1><ol>\n<li><p><strong>Java框架层的Log</strong><br>在编程的时候，大家都用过Log，其实这个我们经常使用的Log工具，在Java框架层最终调用的是native方法。<br>贴上源码的路径：<code>/frameworks/base/core/java/android/util/Log.java</code>。<br>如果感兴趣，可以进去瞧一瞧。咱们以Log.java中的println_native()这个本地方法，进行分析。</p>\n</li>\n<li><p><strong>Log的JNI实现</strong><br>Log的JNI的实现是在一个叫<code>android_util_Log.cpp</code>的源文件中。<br>源码路径：<br>头文件：<code>/frameworks/base/core/jni/android_util_Log.h</code>。<br>源文件：<code>/frameworks/base/core/jni/android_util_Log.cpp</code>。</p>\n</li>\n</ol>\n<p>在android_util_Log.cpp源文件中，我们可以找到println_native的身影。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * JNI registration.</span><br><span class=\"line\"> */</span><br><span class=\"line\">static const JNINativeMethod gMethods[] = &#123;</span><br><span class=\"line\">    /* name, signature, funcPtr */</span><br><span class=\"line\">    &#123; <span class=\"string\">\"isLoggable\"</span>,      <span class=\"string\">\"(Ljava/lang/String;I)Z\"</span>, (void*) android_util_Log_isLoggable &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"println_native\"</span>,  <span class=\"string\">\"(IILjava/lang/String;Ljava/lang/String;)I\"</span>, (void*) android_util_Log_println_native &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"logger_entry_max_payload_native\"</span>,  <span class=\"string\">\"()I\"</span>, (void*) android_util_Log_logger_entry_max_payload_native &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>JNINativeMethod是前面提到的一个结构体，这个结构体表示一个实现的本地方法。这个结构体在jni.h文件中定义，内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    const char* name;</span><br><span class=\"line\">    const char* signature;</span><br><span class=\"line\">    void*       fnPtr;</span><br><span class=\"line\">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p>\n<p>它有三个指针变量，第一个是字符型指针，可以表示一个字符串，即native方法的名称；第二个也是字符型指针，同样可以表示一个字符串，代表这个native方法的参数和返回值（有特殊的表示方法）；第三个是一个未指定类型指针，表示一个函数指针，指向这个native方法对应的jni函数。</p>\n<p>有了对JNINativeMethod了解，就可以理解<code>println_native</code>在<code>android_util_Log.cpp</code>源文件中的含义了。其对应jni实现函数是<code>android_util_Log_println_native()</code>。在jni实现函数中，又调用了<code>__android_log_buf_write()</code>这个方法，<code>__android_log_buf_write</code>是本地框架层（非Java框架层）基础的C库之上，Android最底层的本地Log库。<br>Log库的源码路径为：<br>头文件：<code>system/core/include/cutils/log.h</code>。<br>源文件：<code>system/core/liblog</code>。<br>编译后会生成liblog.so动态库和liblog.a静态库。</p>\n<ol start=\"3\">\n<li><strong>JNI的注册</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int register_android_util_Log(JNIEnv* env)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    jclass clazz = FindClassOrDie(env, <span class=\"string\">\"android/util/Log\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    levels.verbose = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));</span><br><span class=\"line\">    levels.debug = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));</span><br><span class=\"line\">    levels.info = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));</span><br><span class=\"line\">    levels.warn = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));</span><br><span class=\"line\">    levels.error = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));</span><br><span class=\"line\">    levels.assert = env-&gt;GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> RegisterMethodsOrDie(env, <span class=\"string\">\"android/util/Log\"</span>, gMethods, NELEM(gMethods));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这是<code>android_util_Log.cpp</code>源文件中对jni的注册，可以看到RegisterMethodsOrDie()这个方法的调用，传入了我们前面看到的gMethods数组，进行JNI注册。到这里结束了吗？确实第一次看到这里的时候，以为就此结束了。然而，<strong>是谁调用了register_android_util_Log()这个方法？在RegisterMethodsOrDie()这个函数里面又做了什么呢？</strong></p>\n<ol start=\"4\">\n<li><strong>register_android_util_Log()函数的调用</strong><br><code>register_android_util_Log()</code>这个方法只在<code>android_util_Log.cpp</code>源文件中进行定义，需要找到谁对它进行了调用，才好进一步理解Log的JNI的注册过程。Android源码环境有一个非常不错的方法，可以通过字符串，找到出现过的文件。<br>指令：<code>cgrep &#39;register_android_util_Log&#39;</code><br>类似于：<code>find . -type f -name &quot;*.cpp&quot; | xargs grep &quot;register_android_util_Log&quot;</code><br>通过结果可以发现一个AndoridRuntime.cpp，这是个什么鬼？只能说它很强，是系统运行时的工具类，为Android的运行提供支持。JNI的部分封装也在这个类中。<br>源码路径：<br><code>/frameworks/base/include/android_runtime/AndroidRuntime.h</code>。<br><code>/frameworsk/base/core/jni/AndroidRuntime.cpp</code>。<br>可以发现，它也是在/frameworsk/base/core/jni目录下，说明也是在libandroid_runtime.so动态库中。</li>\n</ol>\n<p>在AndroidRuntime.cpp源文件gRegJNI数组中，发现了<code>register_android_util_Log</code>方法。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const RegJNIRec gRegJNI[] = &#123;</span><br><span class=\"line\">    REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class=\"line\">    REG_JNI(register_android_os_SystemClock),</span><br><span class=\"line\">    REG_JNI(register_android_util_EventLog),</span><br><span class=\"line\">    REG_JNI(register_android_util_Log),</span><br><span class=\"line\">    REG_JNI(register_android_util_MemoryIntArray),</span><br><span class=\"line\">    //省略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，又在AndroidRuntime.cpp源文件的<strong>AndroidRuntime::startReg()</strong>这个方法中，使用了gRegJNI这个数组。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * Register android native functions <span class=\"keyword\">with</span> the VM.</span><br><span class=\"line\"> */</span><br><span class=\"line\">/*static*/ int AndroidRuntime::startReg(JNIEnv* env)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ATRACE_NAME(<span class=\"string\">\"RegisterAndroidNatives\"</span>);</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * This hook causes all future threads created <span class=\"keyword\">in</span> this process to be</span><br><span class=\"line\">     * attached to the JavaVM.  (This needs to go away <span class=\"keyword\">in</span> favor of JNI</span><br><span class=\"line\">     * Attach calls.)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class=\"line\"></span><br><span class=\"line\">    ALOGV(<span class=\"string\">\"--- registering native functions ---\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Every <span class=\"string\">\"register\"</span> function calls one <span class=\"keyword\">or</span> more things that <span class=\"keyword\">return</span></span><br><span class=\"line\">     * a local reference (e.g. FindClass).  Because we haven<span class=\"string\">'t really</span></span><br><span class=\"line\"><span class=\"string\">     * started the VM yet, they'</span>re all getting stored <span class=\"keyword\">in</span> the base frame</span><br><span class=\"line\">     * <span class=\"keyword\">and</span> never released.  Use Push/Pop to manage the storage.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    env-&gt;PushLocalFrame(200);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        env-&gt;PopLocalFrame(NULL);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    env-&gt;PopLocalFrame(NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    //createJavaThread(<span class=\"string\">\"fubar\"</span>, quickTest, (void*) <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按源代码注释的意思是，这里在向虚拟机注册本地方法。同样在AndroidRuntime.cpp源文件中，AndroidRuntime::start()中又调用了AndroidRuntime::startReg()，到这里，需要继续往下看，就得找找<strong>是谁调用了AndroidRuntime::start()</strong>方法。然而，要想知道谁调用了它，已经涉及到zygote这一块的知识。</p>\n<ol start=\"5\">\n<li><strong>zygote</strong><br>zygote是通过init进程读取init.rc启动的一个守护进程的名称。如果从最下面开始说，得再介绍一下Android启动流程的本地阶段，这一块，属于扩充了解。</li>\n</ol>\n<p>Android启动流程的本地阶段：</p>\n<ul>\n<li>BootLoader运行，Linux通用内容。</li>\n<li>Linux内核运行，Linux通用内容，通常是二进制形式代码形式存在。</li>\n<li>内核加载根文件系统，Linux通用内容。</li>\n<li>init进程运行，用户空间的第一个进程。</li>\n<li>运行init.rc脚本。</li>\n<li>加载system和date文件系统。</li>\n<li>运行各种服务，主要为各种守护进程。</li>\n</ul>\n<p>本地部分启动完成，形成一系列守护进程，其中名称为zygote的守护进程，将继续完成Java部分的初始化。</p>\n<p>Java部分的启动流程：</p>\n<ul>\n<li>从本地可执行程序运行名为zygote的守护进程。</li>\n<li>zygote运行ZygoteInit（进入Java程序）。</li>\n<li>ZygoteInit运行SystemServer（Java类），并分裂出新的进程。</li>\n<li>SystemServer首先运行libandroid_servers.so库当中的初始化（进入本地程序）。</li>\n<li>执行libanroid_servers.so当中的系统初始化。</li>\n<li>SystemServer中的Java初始化再次被调用（再入Java程序）。</li>\n<li>建立ServerThread线程。</li>\n<li>ServerThread线程建立各个服务，然后进入循环。</li>\n<li>ActivityManagerService在启动结束发送相关信息。</li>\n<li>各个Java应用程序运行。</li>\n</ul>\n<p>这些是引用资料书中的知识，想详细了解，可以看看《Android核心原理及系统级应用高效开发》或《深入理解Android系统》。回到我们的zygote进程，init.rc中包含了一个init.${ro.zygote}.rc。<br>init.rc和init.${ro.zygote}.rc源码路径：<code>/system/core/rootdir</code>。</p>\n<p>在init.zygote32.rc中，相关内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">main</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">socket</span> <span class=\"title\">zygote</span> <span class=\"title\">stream</span> 660 <span class=\"title\">root</span> <span class=\"title\">system</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">write</span> /<span class=\"title\">sys</span>/<span class=\"title\">android_power</span>/<span class=\"title\">request_state</span> <span class=\"title\">wake</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">write</span> /<span class=\"title\">sys</span>/<span class=\"title\">power</span>/<span class=\"title\">state</span> <span class=\"title\">on</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">audioserver</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">cameraserver</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">media</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">onrestart</span> <span class=\"title\">restart</span> <span class=\"title\">netd</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">writepid</span> /<span class=\"title\">dev</span>/<span class=\"title\">cpuset</span>/<span class=\"title\">foreground</span>/<span class=\"title\">tasks</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这个是Android系统中的特殊语法，它启动了一个名称为zygote的进程，也就是<code>/system/bin/app_process</code>这个可执行程序。<br>源码路径为：<code>/frameworks/base/cmds/app_process</code>。<br>在这个目录下，有一个<code>app_main.cpp</code>的源文件，其中相关的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 省略</span><br><span class=\"line\"><span class=\"keyword\">if</span> (zygote) &#123;</span><br><span class=\"line\">    runtime.start(<span class=\"string\">\"com.android.internal.os.ZygoteInit\"</span>, args, zygote);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className) &#123;</span><br><span class=\"line\">    runtime.start(<span class=\"string\">\"com.android.internal.os.RuntimeInit\"</span>, args, zygote);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fprintf(stderr, <span class=\"string\">\"Error: no class name or --zygote supplied.\\n\"</span>);</span><br><span class=\"line\">    app_usage();</span><br><span class=\"line\">    LOG_ALWAYS_FATAL(<span class=\"string\">\"app_process: no class name or --zygote supplied.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>app_main.cpp</code>源文件中，有一个AppRuntime的类，它继承了AndroidRuntime。runtime是AppRuntime类的一个实例，runtime.start()相当于调用了AndroidRuntime::start()这个方法，至此，前后就连接起来了。概括的说，系统启动zygote进程时，会调用AndroidRuntime::start()方法，接着调用AndroidRuntime::startReg()，然后调用到了<code>register_android_util_Log()</code>这个方法。剩下最后一个问题，<code>register_android_util_Log()</code>被调用后，在它方法体中的<strong>RegisterMethodsOrDie()函数做了什么？</strong></p>\n<ol start=\"6\">\n<li><strong>RegisterMethodsOrDie()函数</strong><br>RegisterMethodsOrDie()这个方法是<code>/frameworks/base/core/jni/core_jni_helpers.h</code>中声明的一个方法。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className,</span><br><span class=\"line\">                                       const JNINativeMethod* gMethods, int numMethods) &#123;</span><br><span class=\"line\">    int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(res &lt; <span class=\"number\">0</span>, <span class=\"string\">\"Unable to register native methods.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在其中我们可以看到，其实又回到了AndroidRuntime这个类，调用了它的registerNativeMethods()方法，并最终调用了jniRegisterNativeMethods()进行本地方法的注册。而jniRegisterNativeMethods()是/libnativehelper/JNIHelp.cpp源文件中的方法，它里面内容为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern <span class=\"string\">\"C\"</span> int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,</span><br><span class=\"line\">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class=\"line\"></span><br><span class=\"line\">    ALOGV(<span class=\"string\">\"Registering %s's %d native methods...\"</span>, className, numMethods);</span><br><span class=\"line\"></span><br><span class=\"line\">    scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c.get() == NULL) &#123;</span><br><span class=\"line\">        char* tmp;</span><br><span class=\"line\">        const char* msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asprintf(&amp;tmp,</span><br><span class=\"line\">                     <span class=\"string\">\"Native registration unable to find class '%s'; aborting...\"</span>,</span><br><span class=\"line\">                     className) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            // Allocation failed, <span class=\"keyword\">print</span> default warning.</span><br><span class=\"line\">            msg = <span class=\"string\">\"Native registration unable to find class; aborting...\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e-&gt;FatalError(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) &#123;</span><br><span class=\"line\">        char* tmp;</span><br><span class=\"line\">        const char* msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asprintf(&amp;tmp, <span class=\"string\">\"RegisterNatives failed for '%s'; aborting...\"</span>, className) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            // Allocation failed, <span class=\"keyword\">print</span> default warning.</span><br><span class=\"line\">            msg = <span class=\"string\">\"RegisterNatives failed; aborting...\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e-&gt;FatalError(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码可以看出，通过调用(*env)的RegisterNatives指针函数，进行了JNI注册。所以最后的动作是交给了JNINativeInterface结构体所表示的JNI环境执行。当在Java层调用native方法时，不需要依据native方法包和名称寻找对应的JNI函数。而是可以通过已经注册的映射关系，快速找到对应的JNI函数的指针，从而开始函数调用，大大提高执行效率。</p>"},{"title":"Java8的几个重要特性介绍","_content":"\n`Java8`的新特性有很多，只对代表性的四个重要特性做一次总结，方便以后回顾。\n\n`Java8`的四个重要新特性:\n+ Lambda；\n+ 方法引用；\n+ 默认方法；\n+ Stream。\n<!--more-->\n# 1. Lambda\n\n`Lambda`表达式：Lambda可以让函数当做一个方法的参数进行传递，并且让代码变得更加简洁。`Lambda`表达式省去了匿名类的麻烦，但Lambda只能给包含一个方法的接口定义，且Lambda的入参和返回值必须和接口中的方法一致。\n语法：\n(type param1, type param2…) -> {Statements}\n\nLambda几个特性：\n+ 参数类型可选：编译器可以自动识别参数的类型；\n+ 参数圆括号可选：只有一个参数时，可省略圆括号；\n+ 语句块大括号可选：只有一个语句时，可省略大括号；\n+ 返回值可选：只有一个语句时，可省略返回值。\n\n这四个特性，两个针对参数，两个对应语句块，很好理解，代码分析如下：\n```java\npublic class LambdaTest3 {\n    public static void main(String[] args) {\n\t\t\n\t\t/**\n\t\t * 类型声明，圆括号，大括号的省略情况\n\t\t */\n\t\t\n\t\t// 先看参数部分，主要看类型声明和括号的省略情况\n\t\t// 1.参数类型声明可选\n\t\t// 2.一个参数时，括号可选\n\t\t\n\t\t// 两个参数，没有省略时\n\t\tMathOperate1 mathOperate1_1 = (int a, int b) -> {\n\t\t\tSystem.out.println(\"two parameter\");\n\t\t\treturn a + b;\n\t\t};\n\t\tmathOperate1_1.operate(12, 45);\n\n\t\t// 两个参数，省略参数类型声明\n\t\tMathOperate1 mathOperate1_2 = (a, b) -> {\n\t\t\tSystem.out.println(\"two parameter\");\n\t\t\treturn a + b;\n\t\t};\n\t\tmathOperate1_2.operate(12, 45);\n\n\t\t// 一个参数，带类型声明，必须有括号\n\t\tMathOperate2 mathOperate2_1 = (int a) -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_1.operate(8);\n\n\t\t// 一个参数，省略类型声明\n\t\tMathOperate2 mathOperate2_2 = (a) -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_2.operate(8);\n\n\t\t// 一个参数，省略括号，必须同时省略类型声明\n\t\tMathOperate2 mathOperate2_3 = a -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_3.operate(8);\n\n\t\t// 无参数，不可省略括号\n\t\tMathOperate3 mathOperate3_1 = () -> {\n\t\t\tSystem.out.println(\"no parameter\");\n\t\t\treturn -1;\n\t\t};\n\t\tmathOperate3_1.operate();\n\n\t\t// 语句块部分\n\t\t// 1.一条语句，可省略大括号\n\t\t// 2.一条语句，未省略大括号，有返回值，则必须要return关键字\n\t\t\n\t\t// 多条语句，有返回值，不能省略大括号，不能省略return，若无返回值则不需要return\n\t\tMathOperate1 operate1 = (a, b) -> {\n\t\t\tint c;\n\t\t\treturn c = a + b;\n\t\t};\n\t\toperate1.operate(8, 8);\n\n\t\t// 一条语句，有返回值，有大括号，则必须有return\n\t\tMathOperate1 operate2 = (a, b) -> {\n\t\t\treturn a + b;\n\t\t};\n\t\toperate2.operate(8, 8);\n\t\t\n\t\t// 一条语句，没有返回值，有大括号时，不需要return\n\t\tMathOperate4 operate3 = (a, b) -> {\n\t\t\tint c = a + b;\n\t\t};\n\t\toperate3.operate(8, 8);\n\t\t\n\t\t// 一条语句，省略大括号和return关键字，如果有返回值，表达式结果默认为返回值\n\t\tMathOperate1 operate4 = (a, b) -> a + b;\n\t\toperate4.operate(8, 8);\n\n\t}\n\n\t// 两个参数\n\t@FunctionalInterface\n\tinterface MathOperate1 {\n\t\tint operate(int a, int b);\n\t}\n\n\t// 一个参数\n\t@FunctionalInterface\n\tinterface MathOperate2 {\n\t\tint operate(int a);\n\t}\n\n\t// 无参数\n\t@FunctionalInterface\n\tinterface MathOperate3 {\n\t\tint operate();\n\t}\n\n\t// 无返回值\n\t@FunctionalInterface\n\tinterface MathOperate4 {\n\t\tvoid operate(int a, int b);\n\t}\n\n}\n```\n\n另外，Lambda主体部分可能使用外部的变量，当Lambda要使用外部的变量时，其内部不能修改外部变量的值。\n```java\npublic class LambdaTest2 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t/**\n\t\t * 作用域问题\n\t\t */\n\t\t\n\t\t// 引用一个块外部的变量，在内部不能修改它的值\n\t\tint c = 12; \n\t\ttest2(56, 45, (a, b) -> {\n\t\t\ta += 2;\n\t\t\tb += 2;\n\t\t\tint d = a + b + c;\n\t\t\tSystem.out.println(d);\n\t\t});\n\t}\n\n\tprivate static void test2(int a, int b, LambdaTestInterface2 lam2) {\n\t\tlam2.init(a, b);\n\t}\n\n\tpublic interface LambdaTestInterface2 {\n\t\tvoid init(int a, int b);\n\t}\n}\n```\n\n如何理解java 8中引入的Lambda表达式？匿名类，从这里着手看看，在此之前，接口对象，可用匿名类实例化。而Lambda可以理解为接口的另一种实例化的方法，但前提是这个接口只能有一个抽象方法。\n```java\npublic class LambdaTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * lambda和匿名类的对比\n\t\t */\n\n\t\t// 匿名类的写法，当参数使用\n\t\tint result1 = operation(8, 8, new MathOperate() {\n\t\t\t@Override\n\t\t\tpublic int operate(int a, int b) {\n\t\t\t\treturn a + b;\n\t\t\t}\n\t\t});\n\n\t\t// lambda，同样当参数使用\n\t\tint result2 = operation(8, 8, (a, b) -> a + b);\n\n\t\tSystem.out.println(result1);\n\t\tSystem.out.println(result2);\n\t}\n\n\tprivate static int operation(int a, int b, MathOperate mathOperate) {\n\t\treturn mathOperate.operate(a, b);\n\t}\n\n\t@FunctionalInterface\n\tinterface MathOperate {\n\t\tint operate(int a, int b);\n\t}\n}\n```\n\n# 2. 方法引用\n\n使用“::”进行方法引用，按引用的方法分三类：\n+ 静态方法；\n+ 构造方法；\n+ 成员方法。\n\n引用静态方法，类名::方法名。方法参数和返回值需要和接口中的一致；\n引用构造函数，类名::new。构造函数需要和接口中参数一致；\n引用对象方法，对象.方法名。方法参数和返回值需要和接口中的一致，不能通过对象引用静态方法。\n```java\npublic class MethodJava8 {\n\tpublic static void main(String[] args) {\n\n\t\t/**\n\t\t * 方法引用\n\t\t */\n\t\t\n\t\t// ::可以引用静态方法，对象的方法或构造函数\n\t\t// 1.静态方法引用，引用方法的形参和返回值，需和接口中的一致\n\t\tConvert<String, Integer> convert = Integer::valueOf;\n\t\tSystem.out.println(convert.convert(\"888\"));\n\t\t// 匿名类的方法实现\n\t\tConvert<String, Integer> convert2 = new Convert<String, Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic Integer convert(String t1) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn Integer.valueOf(t1);\n\t\t\t}\n\n\t\t};\n\t\tSystem.out.println(convert2.convert(\"999\"));\n\n\t\t// 引用自定义类的静态方法\n\t\tConvert<String, Integer> convert3 = MyConvert::convert;\n\t\tSystem.out.println(convert3.convert(\"101010\"));\n\n\t\t// 2.引用对象中的方法，静态方法不能通过对象引用\n\t\tMyConvert myConvert = new MethodJava8.MyConvert();\n\t\t//引用对象的成员方法\n\t\tConvert<String, Integer> convert4 = myConvert::convert2;\n\t\t// Convert<String, Integer> convert4 = myConvert::convert; //错误，不能引用静态方法\n\t\tSystem.out.println(convert4.convert(\"111111\"));\n\n\t\t// 3.引用User的构造函数\n\t\tUserFactory<User> userfactory = User::new;\n\t\tUser user = userfactory.create(\"Test2\", 22, \"male\");\n\t\tSystem.out.println(user.getName());\n\n\t\t// 匿名类实现UserFactory\n\t\tUserFactory<User> userfactory2 = new UserFactory<User>() {\n\t\t\t@Override\n\t\t\tpublic User create(String name, int age, String gendle) {\n\t\t\t\treturn new User(name, age, gendle);\n\t\t\t}\n\t\t};\n\t\tSystem.out.println(userfactory2.create(\"Test1\", 11, \"female\").getName());\n\t}\n\n\t@FunctionalInterface\n\tinterface Convert<T1, T2> {\n\t\tT2 convert(T1 t1);\n\t}\n\n\tinterface UserFactory<U extends User> {\n\t\tU create(String name, int age, String gendle);\n\t}\n\t\n\tpublic static class MyConvert {\n\n\t\tpublic static Integer convert(String t1) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn Integer.valueOf(t1);\n\t\t}\n\t\t\n\t\tpublic Integer convert2(String t1){\n\n\t\t\treturn Integer.valueOf(t1);\n\t\t}\n\t}\n}\n```\n\n# 3. 默认方法\n\n在接口的方法前加default关键字，表示一个默认方法，加static表示默认静态方法。\n有了默认方法，在需求变更的时候，不必因增加接口中的方法，而需要重新实现已经实现该接口的类。\n\n```java\npublic class DefaultMethod {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * 默认方法\n\t\t */\n\t\t\n\t\tMyDefaultMethodTest.operate();\n\t\t\n\t\tMyDefaultMethodTest myDefaultMethodTest = new MyDefaultMethodTest() {\n\t\t};\n\t\t\n\t\tmyDefaultMethodTest.init();\n\t}\n\n\tpublic interface MyDefaultMethodTest {\n\t\t// 默认方法\n\t\tdefault void init() {\n\t\t\tSystem.out.println(\"It is init() in MyDefaultMethodTest\");\n\n\t\t}\n\t\t\n\t\t//默认静态方法，不能通过对象访问\n\t\tstatic void operate() {\n\t\t\tSystem.out.println(\"It is operate() in MyDefaultMethodTest\");\n\t\t}\n\t}\n\n}\n```\n\n# 4. Stream\n\nStream，类似把操作的对象看成一个数据流，对它操作后会返回被处理后的流，可以继续操作，比如排序，过滤，变换等等。\n+ 数据流的生成\n集合，数组，IO，产生器等。\n+ 数据流操作\nforeach，map，filter，limit，sorted，parallel等。\n```java\npublic class StreamJava8 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * 创建Stream流\n\t\t */\n\t\tList<String> list = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n\t\tList<String> filtered1 = list.stream()\n\t\t\t\t.filter(string -> !string.isEmpty())\n\t\t\t\t.collect(Collectors.toList());\n\t\t/**\n\t\t * 聚合操作\n\t\t */\n\t\t// foreach\n\t\tfiltered1.forEach(s -> System.out.println(s));\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// map\n\t\tList<Integer> mapNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> mapResult = mapNumbers.stream().map(a -> a * a)\n\t\t\t\t.distinct().collect(Collectors.toList());\n\t\tmapResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// filter\n\t\tList<Integer> filterNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> filterResult = filterNumbers.stream().filter(a -> a > 5)\n\t\t\t\t.collect(Collectors.toList());\n\t\tfilterResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// limit\n\t\tList<String> limitStr = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n\t\tList<String> limitResult = limitStr.stream().limit(2)\n\t\t\t\t.collect(Collectors.toList());\n\t\tlimitResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// sorted\n\t\tList<Integer> sortedNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> sortedResult = sortedNumbers.stream()\n\t\t\t\t.sorted((a, b) -> a < b ? 1 : a == b ? 0 : -1)\n\t\t\t\t.collect(Collectors.toList());\n\t\tsortedResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// parallel\n\t\tList<String> parallelNumbers = Arrays.asList(\"a\", \"d\", \"a\", \"b\", \"c\",\n\t\t\t\t\"d\", \"e\", \"f\");\n\t\tList<String> parallelResult = parallelNumbers.parallelStream()\n\t\t\t\t.filter(str -> str.equals(\"a\")).collect(Collectors.toList());\n\t\tparallelResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// Collectors\n\t\tList<String> collectorsStr = Arrays.asList(\"a\", \"d\", \"a\", \"b\", \"c\",\n\t\t\t\t\"d\", \"e\", \"f\");\n\t\t// 返回List\n\t\tList<String> collectorResultList = collectorsStr.stream()\n\t\t\t\t.filter(str -> !str.isEmpty()).collect(Collectors.toList());\n\t\tSystem.out.println(\"列表: \" + collectorResultList);\n\t\t// 返回String\n\t\tString collectorResultString = collectorsStr.parallelStream()\n\t\t\t\t.filter(str -> !str.isEmpty()).collect(Collectors.joining(\"+\"));\n\t\tSystem.out.println(\"合并: \" + collectorResultString);\n\t}\n\n}\n```\n能力有限，先写到这，部分要点来自网络，仅作学习之用。\n","source":"_posts/java8.md","raw":"---\ntitle: Java8的几个重要特性介绍\n---\n\n`Java8`的新特性有很多，只对代表性的四个重要特性做一次总结，方便以后回顾。\n\n`Java8`的四个重要新特性:\n+ Lambda；\n+ 方法引用；\n+ 默认方法；\n+ Stream。\n<!--more-->\n# 1. Lambda\n\n`Lambda`表达式：Lambda可以让函数当做一个方法的参数进行传递，并且让代码变得更加简洁。`Lambda`表达式省去了匿名类的麻烦，但Lambda只能给包含一个方法的接口定义，且Lambda的入参和返回值必须和接口中的方法一致。\n语法：\n(type param1, type param2…) -> {Statements}\n\nLambda几个特性：\n+ 参数类型可选：编译器可以自动识别参数的类型；\n+ 参数圆括号可选：只有一个参数时，可省略圆括号；\n+ 语句块大括号可选：只有一个语句时，可省略大括号；\n+ 返回值可选：只有一个语句时，可省略返回值。\n\n这四个特性，两个针对参数，两个对应语句块，很好理解，代码分析如下：\n```java\npublic class LambdaTest3 {\n    public static void main(String[] args) {\n\t\t\n\t\t/**\n\t\t * 类型声明，圆括号，大括号的省略情况\n\t\t */\n\t\t\n\t\t// 先看参数部分，主要看类型声明和括号的省略情况\n\t\t// 1.参数类型声明可选\n\t\t// 2.一个参数时，括号可选\n\t\t\n\t\t// 两个参数，没有省略时\n\t\tMathOperate1 mathOperate1_1 = (int a, int b) -> {\n\t\t\tSystem.out.println(\"two parameter\");\n\t\t\treturn a + b;\n\t\t};\n\t\tmathOperate1_1.operate(12, 45);\n\n\t\t// 两个参数，省略参数类型声明\n\t\tMathOperate1 mathOperate1_2 = (a, b) -> {\n\t\t\tSystem.out.println(\"two parameter\");\n\t\t\treturn a + b;\n\t\t};\n\t\tmathOperate1_2.operate(12, 45);\n\n\t\t// 一个参数，带类型声明，必须有括号\n\t\tMathOperate2 mathOperate2_1 = (int a) -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_1.operate(8);\n\n\t\t// 一个参数，省略类型声明\n\t\tMathOperate2 mathOperate2_2 = (a) -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_2.operate(8);\n\n\t\t// 一个参数，省略括号，必须同时省略类型声明\n\t\tMathOperate2 mathOperate2_3 = a -> {\n\t\t\tSystem.out.println(\"one parameter\");\n\t\t\treturn a;\n\t\t};\n\t\tmathOperate2_3.operate(8);\n\n\t\t// 无参数，不可省略括号\n\t\tMathOperate3 mathOperate3_1 = () -> {\n\t\t\tSystem.out.println(\"no parameter\");\n\t\t\treturn -1;\n\t\t};\n\t\tmathOperate3_1.operate();\n\n\t\t// 语句块部分\n\t\t// 1.一条语句，可省略大括号\n\t\t// 2.一条语句，未省略大括号，有返回值，则必须要return关键字\n\t\t\n\t\t// 多条语句，有返回值，不能省略大括号，不能省略return，若无返回值则不需要return\n\t\tMathOperate1 operate1 = (a, b) -> {\n\t\t\tint c;\n\t\t\treturn c = a + b;\n\t\t};\n\t\toperate1.operate(8, 8);\n\n\t\t// 一条语句，有返回值，有大括号，则必须有return\n\t\tMathOperate1 operate2 = (a, b) -> {\n\t\t\treturn a + b;\n\t\t};\n\t\toperate2.operate(8, 8);\n\t\t\n\t\t// 一条语句，没有返回值，有大括号时，不需要return\n\t\tMathOperate4 operate3 = (a, b) -> {\n\t\t\tint c = a + b;\n\t\t};\n\t\toperate3.operate(8, 8);\n\t\t\n\t\t// 一条语句，省略大括号和return关键字，如果有返回值，表达式结果默认为返回值\n\t\tMathOperate1 operate4 = (a, b) -> a + b;\n\t\toperate4.operate(8, 8);\n\n\t}\n\n\t// 两个参数\n\t@FunctionalInterface\n\tinterface MathOperate1 {\n\t\tint operate(int a, int b);\n\t}\n\n\t// 一个参数\n\t@FunctionalInterface\n\tinterface MathOperate2 {\n\t\tint operate(int a);\n\t}\n\n\t// 无参数\n\t@FunctionalInterface\n\tinterface MathOperate3 {\n\t\tint operate();\n\t}\n\n\t// 无返回值\n\t@FunctionalInterface\n\tinterface MathOperate4 {\n\t\tvoid operate(int a, int b);\n\t}\n\n}\n```\n\n另外，Lambda主体部分可能使用外部的变量，当Lambda要使用外部的变量时，其内部不能修改外部变量的值。\n```java\npublic class LambdaTest2 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t/**\n\t\t * 作用域问题\n\t\t */\n\t\t\n\t\t// 引用一个块外部的变量，在内部不能修改它的值\n\t\tint c = 12; \n\t\ttest2(56, 45, (a, b) -> {\n\t\t\ta += 2;\n\t\t\tb += 2;\n\t\t\tint d = a + b + c;\n\t\t\tSystem.out.println(d);\n\t\t});\n\t}\n\n\tprivate static void test2(int a, int b, LambdaTestInterface2 lam2) {\n\t\tlam2.init(a, b);\n\t}\n\n\tpublic interface LambdaTestInterface2 {\n\t\tvoid init(int a, int b);\n\t}\n}\n```\n\n如何理解java 8中引入的Lambda表达式？匿名类，从这里着手看看，在此之前，接口对象，可用匿名类实例化。而Lambda可以理解为接口的另一种实例化的方法，但前提是这个接口只能有一个抽象方法。\n```java\npublic class LambdaTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * lambda和匿名类的对比\n\t\t */\n\n\t\t// 匿名类的写法，当参数使用\n\t\tint result1 = operation(8, 8, new MathOperate() {\n\t\t\t@Override\n\t\t\tpublic int operate(int a, int b) {\n\t\t\t\treturn a + b;\n\t\t\t}\n\t\t});\n\n\t\t// lambda，同样当参数使用\n\t\tint result2 = operation(8, 8, (a, b) -> a + b);\n\n\t\tSystem.out.println(result1);\n\t\tSystem.out.println(result2);\n\t}\n\n\tprivate static int operation(int a, int b, MathOperate mathOperate) {\n\t\treturn mathOperate.operate(a, b);\n\t}\n\n\t@FunctionalInterface\n\tinterface MathOperate {\n\t\tint operate(int a, int b);\n\t}\n}\n```\n\n# 2. 方法引用\n\n使用“::”进行方法引用，按引用的方法分三类：\n+ 静态方法；\n+ 构造方法；\n+ 成员方法。\n\n引用静态方法，类名::方法名。方法参数和返回值需要和接口中的一致；\n引用构造函数，类名::new。构造函数需要和接口中参数一致；\n引用对象方法，对象.方法名。方法参数和返回值需要和接口中的一致，不能通过对象引用静态方法。\n```java\npublic class MethodJava8 {\n\tpublic static void main(String[] args) {\n\n\t\t/**\n\t\t * 方法引用\n\t\t */\n\t\t\n\t\t// ::可以引用静态方法，对象的方法或构造函数\n\t\t// 1.静态方法引用，引用方法的形参和返回值，需和接口中的一致\n\t\tConvert<String, Integer> convert = Integer::valueOf;\n\t\tSystem.out.println(convert.convert(\"888\"));\n\t\t// 匿名类的方法实现\n\t\tConvert<String, Integer> convert2 = new Convert<String, Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic Integer convert(String t1) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn Integer.valueOf(t1);\n\t\t\t}\n\n\t\t};\n\t\tSystem.out.println(convert2.convert(\"999\"));\n\n\t\t// 引用自定义类的静态方法\n\t\tConvert<String, Integer> convert3 = MyConvert::convert;\n\t\tSystem.out.println(convert3.convert(\"101010\"));\n\n\t\t// 2.引用对象中的方法，静态方法不能通过对象引用\n\t\tMyConvert myConvert = new MethodJava8.MyConvert();\n\t\t//引用对象的成员方法\n\t\tConvert<String, Integer> convert4 = myConvert::convert2;\n\t\t// Convert<String, Integer> convert4 = myConvert::convert; //错误，不能引用静态方法\n\t\tSystem.out.println(convert4.convert(\"111111\"));\n\n\t\t// 3.引用User的构造函数\n\t\tUserFactory<User> userfactory = User::new;\n\t\tUser user = userfactory.create(\"Test2\", 22, \"male\");\n\t\tSystem.out.println(user.getName());\n\n\t\t// 匿名类实现UserFactory\n\t\tUserFactory<User> userfactory2 = new UserFactory<User>() {\n\t\t\t@Override\n\t\t\tpublic User create(String name, int age, String gendle) {\n\t\t\t\treturn new User(name, age, gendle);\n\t\t\t}\n\t\t};\n\t\tSystem.out.println(userfactory2.create(\"Test1\", 11, \"female\").getName());\n\t}\n\n\t@FunctionalInterface\n\tinterface Convert<T1, T2> {\n\t\tT2 convert(T1 t1);\n\t}\n\n\tinterface UserFactory<U extends User> {\n\t\tU create(String name, int age, String gendle);\n\t}\n\t\n\tpublic static class MyConvert {\n\n\t\tpublic static Integer convert(String t1) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn Integer.valueOf(t1);\n\t\t}\n\t\t\n\t\tpublic Integer convert2(String t1){\n\n\t\t\treturn Integer.valueOf(t1);\n\t\t}\n\t}\n}\n```\n\n# 3. 默认方法\n\n在接口的方法前加default关键字，表示一个默认方法，加static表示默认静态方法。\n有了默认方法，在需求变更的时候，不必因增加接口中的方法，而需要重新实现已经实现该接口的类。\n\n```java\npublic class DefaultMethod {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * 默认方法\n\t\t */\n\t\t\n\t\tMyDefaultMethodTest.operate();\n\t\t\n\t\tMyDefaultMethodTest myDefaultMethodTest = new MyDefaultMethodTest() {\n\t\t};\n\t\t\n\t\tmyDefaultMethodTest.init();\n\t}\n\n\tpublic interface MyDefaultMethodTest {\n\t\t// 默认方法\n\t\tdefault void init() {\n\t\t\tSystem.out.println(\"It is init() in MyDefaultMethodTest\");\n\n\t\t}\n\t\t\n\t\t//默认静态方法，不能通过对象访问\n\t\tstatic void operate() {\n\t\t\tSystem.out.println(\"It is operate() in MyDefaultMethodTest\");\n\t\t}\n\t}\n\n}\n```\n\n# 4. Stream\n\nStream，类似把操作的对象看成一个数据流，对它操作后会返回被处理后的流，可以继续操作，比如排序，过滤，变换等等。\n+ 数据流的生成\n集合，数组，IO，产生器等。\n+ 数据流操作\nforeach，map，filter，limit，sorted，parallel等。\n```java\npublic class StreamJava8 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\t/**\n\t\t * 创建Stream流\n\t\t */\n\t\tList<String> list = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n\t\tList<String> filtered1 = list.stream()\n\t\t\t\t.filter(string -> !string.isEmpty())\n\t\t\t\t.collect(Collectors.toList());\n\t\t/**\n\t\t * 聚合操作\n\t\t */\n\t\t// foreach\n\t\tfiltered1.forEach(s -> System.out.println(s));\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// map\n\t\tList<Integer> mapNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> mapResult = mapNumbers.stream().map(a -> a * a)\n\t\t\t\t.distinct().collect(Collectors.toList());\n\t\tmapResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// filter\n\t\tList<Integer> filterNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> filterResult = filterNumbers.stream().filter(a -> a > 5)\n\t\t\t\t.collect(Collectors.toList());\n\t\tfilterResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// limit\n\t\tList<String> limitStr = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n\t\tList<String> limitResult = limitStr.stream().limit(2)\n\t\t\t\t.collect(Collectors.toList());\n\t\tlimitResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// sorted\n\t\tList<Integer> sortedNumbers = Arrays.asList(11, 2, 2, 6, 4, 3, 9);\n\t\tList<Integer> sortedResult = sortedNumbers.stream()\n\t\t\t\t.sorted((a, b) -> a < b ? 1 : a == b ? 0 : -1)\n\t\t\t\t.collect(Collectors.toList());\n\t\tsortedResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// parallel\n\t\tList<String> parallelNumbers = Arrays.asList(\"a\", \"d\", \"a\", \"b\", \"c\",\n\t\t\t\t\"d\", \"e\", \"f\");\n\t\tList<String> parallelResult = parallelNumbers.parallelStream()\n\t\t\t\t.filter(str -> str.equals(\"a\")).collect(Collectors.toList());\n\t\tparallelResult.forEach(System.out::println);\n\t\tSystem.out.print(\"\\n\");\n\n\t\t// Collectors\n\t\tList<String> collectorsStr = Arrays.asList(\"a\", \"d\", \"a\", \"b\", \"c\",\n\t\t\t\t\"d\", \"e\", \"f\");\n\t\t// 返回List\n\t\tList<String> collectorResultList = collectorsStr.stream()\n\t\t\t\t.filter(str -> !str.isEmpty()).collect(Collectors.toList());\n\t\tSystem.out.println(\"列表: \" + collectorResultList);\n\t\t// 返回String\n\t\tString collectorResultString = collectorsStr.parallelStream()\n\t\t\t\t.filter(str -> !str.isEmpty()).collect(Collectors.joining(\"+\"));\n\t\tSystem.out.println(\"合并: \" + collectorResultString);\n\t}\n\n}\n```\n能力有限，先写到这，部分要点来自网络，仅作学习之用。\n","slug":"java8","published":1,"date":"2018-07-12T08:52:08.447Z","updated":"2018-07-12T08:52:08.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjllstdb60006idfsd0ka5o0x","content":"<p><code>Java8</code>的新特性有很多，只对代表性的四个重要特性做一次总结，方便以后回顾。</p>\n<p><code>Java8</code>的四个重要新特性:</p>\n<ul>\n<li>Lambda；</li>\n<li>方法引用；</li>\n<li>默认方法；</li>\n<li>Stream。<a id=\"more\"></a>\n<h1 id=\"1-Lambda\"><a href=\"#1-Lambda\" class=\"headerlink\" title=\"1. Lambda\"></a>1. Lambda</h1></li>\n</ul>\n<p><code>Lambda</code>表达式：Lambda可以让函数当做一个方法的参数进行传递，并且让代码变得更加简洁。<code>Lambda</code>表达式省去了匿名类的麻烦，但Lambda只能给包含一个方法的接口定义，且Lambda的入参和返回值必须和接口中的方法一致。<br>语法：<br>(type param1, type param2…) -&gt; {Statements}</p>\n<p>Lambda几个特性：</p>\n<ul>\n<li>参数类型可选：编译器可以自动识别参数的类型；</li>\n<li>参数圆括号可选：只有一个参数时，可省略圆括号；</li>\n<li>语句块大括号可选：只有一个语句时，可省略大括号；</li>\n<li>返回值可选：只有一个语句时，可省略返回值。</li>\n</ul>\n<p>这四个特性，两个针对参数，两个对应语句块，很好理解，代码分析如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 类型声明，圆括号，大括号的省略情况</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 先看参数部分，主要看类型声明和括号的省略情况</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.参数类型声明可选</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.一个参数时，括号可选</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 两个参数，没有省略时</span></span><br><span class=\"line\">\t\tMathOperate1 mathOperate1_1 = (<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"two parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate1_1.operate(<span class=\"number\">12</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 两个参数，省略参数类型声明</span></span><br><span class=\"line\">\t\tMathOperate1 mathOperate1_2 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"two parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate1_2.operate(<span class=\"number\">12</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，带类型声明，必须有括号</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_1 = (<span class=\"keyword\">int</span> a) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_1.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，省略类型声明</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_2 = (a) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_2.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，省略括号，必须同时省略类型声明</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_3 = a -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_3.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 无参数，不可省略括号</span></span><br><span class=\"line\">\t\tMathOperate3 mathOperate3_1 = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"no parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate3_1.operate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 语句块部分</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.一条语句，可省略大括号</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.一条语句，未省略大括号，有返回值，则必须要return关键字</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 多条语句，有返回值，不能省略大括号，不能省略return，若无返回值则不需要return</span></span><br><span class=\"line\">\t\tMathOperate1 operate1 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> c = a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate1.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，有返回值，有大括号，则必须有return</span></span><br><span class=\"line\">\t\tMathOperate1 operate2 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate2.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，没有返回值，有大括号时，不需要return</span></span><br><span class=\"line\">\t\tMathOperate4 operate3 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate3.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，省略大括号和return关键字，如果有返回值，表达式结果默认为返回值</span></span><br><span class=\"line\">\t\tMathOperate1 operate4 = (a, b) -&gt; a + b;</span><br><span class=\"line\">\t\toperate4.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 两个参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate1</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 一个参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate2</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 无参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate3</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 无返回值</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate4</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，Lambda主体部分可能使用外部的变量，当Lambda要使用外部的变量时，其内部不能修改外部变量的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 作用域问题</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 引用一个块外部的变量，在内部不能修改它的值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> c = <span class=\"number\">12</span>; </span><br><span class=\"line\">\t\ttest2(<span class=\"number\">56</span>, <span class=\"number\">45</span>, (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\ta += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tb += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> d = a + b + c;</span><br><span class=\"line\">\t\t\tSystem.out.println(d);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, LambdaTestInterface2 lam2)</span> </span>&#123;</span><br><span class=\"line\">\t\tlam2.init(a, b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LambdaTestInterface2</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如何理解java 8中引入的Lambda表达式？匿名类，从这里着手看看，在此之前，接口对象，可用匿名类实例化。而Lambda可以理解为接口的另一种实例化的方法，但前提是这个接口只能有一个抽象方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * lambda和匿名类的对比</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类的写法，当参数使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> result1 = operation(<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"keyword\">new</span> MathOperate() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// lambda，同样当参数使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> result2 = operation(<span class=\"number\">8</span>, <span class=\"number\">8</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(result1);</span><br><span class=\"line\">\t\tSystem.out.println(result2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">operation</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, MathOperate mathOperate)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mathOperate.operate(a, b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-方法引用\"><a href=\"#2-方法引用\" class=\"headerlink\" title=\"2. 方法引用\"></a>2. 方法引用</h1><p>使用“::”进行方法引用，按引用的方法分三类：</p>\n<ul>\n<li>静态方法；</li>\n<li>构造方法；</li>\n<li>成员方法。</li>\n</ul>\n<p>引用静态方法，类名::方法名。方法参数和返回值需要和接口中的一致；<br>引用构造函数，类名::new。构造函数需要和接口中参数一致；<br>引用对象方法，对象.方法名。方法参数和返回值需要和接口中的一致，不能通过对象引用静态方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodJava8</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 方法引用</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// ::可以引用静态方法，对象的方法或构造函数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.静态方法引用，引用方法的形参和返回值，需和接口中的一致</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert = Integer::valueOf;</span><br><span class=\"line\">\t\tSystem.out.println(convert.convert(<span class=\"string\">\"888\"</span>));</span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类的方法实现</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert2 = <span class=\"keyword\">new</span> Convert&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">convert</span><span class=\"params\">(String t1)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(convert2.convert(<span class=\"string\">\"999\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 引用自定义类的静态方法</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert3 = MyConvert::convert;</span><br><span class=\"line\">\t\tSystem.out.println(convert3.convert(<span class=\"string\">\"101010\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.引用对象中的方法，静态方法不能通过对象引用</span></span><br><span class=\"line\">\t\tMyConvert myConvert = <span class=\"keyword\">new</span> MethodJava8.MyConvert();</span><br><span class=\"line\">\t\t<span class=\"comment\">//引用对象的成员方法</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert4 = myConvert::convert2;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Convert&lt;String, Integer&gt; convert4 = myConvert::convert; //错误，不能引用静态方法</span></span><br><span class=\"line\">\t\tSystem.out.println(convert4.convert(<span class=\"string\">\"111111\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 3.引用User的构造函数</span></span><br><span class=\"line\">\t\tUserFactory&lt;User&gt; userfactory = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\t\tUser user = userfactory.create(<span class=\"string\">\"Test2\"</span>, <span class=\"number\">22</span>, <span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(user.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类实现UserFactory</span></span><br><span class=\"line\">\t\tUserFactory&lt;User&gt; userfactory2 = <span class=\"keyword\">new</span> UserFactory&lt;User&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">create</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, String gendle)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(name, age, gendle);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(userfactory2.create(<span class=\"string\">\"Test1\"</span>, <span class=\"number\">11</span>, <span class=\"string\">\"female\"</span>).getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Convert</span>&lt;<span class=\"title\">T1</span>, <span class=\"title\">T2</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">T2 <span class=\"title\">convert</span><span class=\"params\">(T1 t1)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserFactory</span>&lt;<span class=\"title\">U</span> <span class=\"keyword\">extends</span> <span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">U <span class=\"title\">create</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, String gendle)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConvert</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">convert</span><span class=\"params\">(String t1)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">convert2</span><span class=\"params\">(String t1)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-默认方法\"><a href=\"#3-默认方法\" class=\"headerlink\" title=\"3. 默认方法\"></a>3. 默认方法</h1><p>在接口的方法前加default关键字，表示一个默认方法，加static表示默认静态方法。<br>有了默认方法，在需求变更的时候，不必因增加接口中的方法，而需要重新实现已经实现该接口的类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultMethod</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 默认方法</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tMyDefaultMethodTest.operate();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tMyDefaultMethodTest myDefaultMethodTest = <span class=\"keyword\">new</span> MyDefaultMethodTest() &#123;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmyDefaultMethodTest.init();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyDefaultMethodTest</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"It is init() in MyDefaultMethodTest\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//默认静态方法，不能通过对象访问</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">operate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"It is operate() in MyDefaultMethodTest\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Stream\"><a href=\"#4-Stream\" class=\"headerlink\" title=\"4. Stream\"></a>4. Stream</h1><p>Stream，类似把操作的对象看成一个数据流，对它操作后会返回被处理后的流，可以继续操作，比如排序，过滤，变换等等。</p>\n<ul>\n<li>数据流的生成<br>集合，数组，IO，产生器等。</li>\n<li>数据流操作<br>foreach，map，filter，limit，sorted，parallel等。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamJava8</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 创建Stream流</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; filtered1 = list.stream()</span><br><span class=\"line\">\t\t\t\t.filter(string -&gt; !string.isEmpty())</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 聚合操作</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// foreach</span></span><br><span class=\"line\">\t\tfiltered1.forEach(s -&gt; System.out.println(s));</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// map</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; mapNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; mapResult = mapNumbers.stream().map(a -&gt; a * a)</span><br><span class=\"line\">\t\t\t\t.distinct().collect(Collectors.toList());</span><br><span class=\"line\">\t\tmapResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// filter</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; filterNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; filterResult = filterNumbers.stream().filter(a -&gt; a &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tfilterResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// limit</span></span><br><span class=\"line\">\t\tList&lt;String&gt; limitStr = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; limitResult = limitStr.stream().limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tlimitResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// sorted</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; sortedNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; sortedResult = sortedNumbers.stream()</span><br><span class=\"line\">\t\t\t\t.sorted((a, b) -&gt; a &lt; b ? <span class=\"number\">1</span> : a == b ? <span class=\"number\">0</span> : -<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tsortedResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// parallel</span></span><br><span class=\"line\">\t\tList&lt;String&gt; parallelNumbers = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; parallelResult = parallelNumbers.parallelStream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; str.equals(<span class=\"string\">\"a\"</span>)).collect(Collectors.toList());</span><br><span class=\"line\">\t\tparallelResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collectors</span></span><br><span class=\"line\">\t\tList&lt;String&gt; collectorsStr = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回List</span></span><br><span class=\"line\">\t\tList&lt;String&gt; collectorResultList = collectorsStr.stream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; !str.isEmpty()).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"列表: \"</span> + collectorResultList);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回String</span></span><br><span class=\"line\">\t\tString collectorResultString = collectorsStr.parallelStream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; !str.isEmpty()).collect(Collectors.joining(<span class=\"string\">\"+\"</span>));</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"合并: \"</span> + collectorResultString);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>能力有限，先写到这，部分要点来自网络，仅作学习之用。</p>\n","site":{"data":{}},"excerpt":"<p><code>Java8</code>的新特性有很多，只对代表性的四个重要特性做一次总结，方便以后回顾。</p>\n<p><code>Java8</code>的四个重要新特性:</p>\n<ul>\n<li>Lambda；</li>\n<li>方法引用；</li>\n<li>默认方法；</li>\n<li>Stream。</li></ul>","more":"<h1 id=\"1-Lambda\"><a href=\"#1-Lambda\" class=\"headerlink\" title=\"1. Lambda\"></a>1. Lambda</h1>\n\n<p><code>Lambda</code>表达式：Lambda可以让函数当做一个方法的参数进行传递，并且让代码变得更加简洁。<code>Lambda</code>表达式省去了匿名类的麻烦，但Lambda只能给包含一个方法的接口定义，且Lambda的入参和返回值必须和接口中的方法一致。<br>语法：<br>(type param1, type param2…) -&gt; {Statements}</p>\n<p>Lambda几个特性：</p>\n<ul>\n<li>参数类型可选：编译器可以自动识别参数的类型；</li>\n<li>参数圆括号可选：只有一个参数时，可省略圆括号；</li>\n<li>语句块大括号可选：只有一个语句时，可省略大括号；</li>\n<li>返回值可选：只有一个语句时，可省略返回值。</li>\n</ul>\n<p>这四个特性，两个针对参数，两个对应语句块，很好理解，代码分析如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 类型声明，圆括号，大括号的省略情况</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 先看参数部分，主要看类型声明和括号的省略情况</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.参数类型声明可选</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.一个参数时，括号可选</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 两个参数，没有省略时</span></span><br><span class=\"line\">\t\tMathOperate1 mathOperate1_1 = (<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"two parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate1_1.operate(<span class=\"number\">12</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 两个参数，省略参数类型声明</span></span><br><span class=\"line\">\t\tMathOperate1 mathOperate1_2 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"two parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate1_2.operate(<span class=\"number\">12</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，带类型声明，必须有括号</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_1 = (<span class=\"keyword\">int</span> a) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_1.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，省略类型声明</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_2 = (a) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_2.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一个参数，省略括号，必须同时省略类型声明</span></span><br><span class=\"line\">\t\tMathOperate2 mathOperate2_3 = a -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"one parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate2_3.operate(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 无参数，不可省略括号</span></span><br><span class=\"line\">\t\tMathOperate3 mathOperate3_1 = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"no parameter\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tmathOperate3_1.operate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 语句块部分</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.一条语句，可省略大括号</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.一条语句，未省略大括号，有返回值，则必须要return关键字</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 多条语句，有返回值，不能省略大括号，不能省略return，若无返回值则不需要return</span></span><br><span class=\"line\">\t\tMathOperate1 operate1 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> c = a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate1.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，有返回值，有大括号，则必须有return</span></span><br><span class=\"line\">\t\tMathOperate1 operate2 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate2.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，没有返回值，有大括号时，不需要return</span></span><br><span class=\"line\">\t\tMathOperate4 operate3 = (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\toperate3.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 一条语句，省略大括号和return关键字，如果有返回值，表达式结果默认为返回值</span></span><br><span class=\"line\">\t\tMathOperate1 operate4 = (a, b) -&gt; a + b;</span><br><span class=\"line\">\t\toperate4.operate(<span class=\"number\">8</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 两个参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate1</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 一个参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate2</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 无参数</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate3</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 无返回值</span></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate4</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，Lambda主体部分可能使用外部的变量，当Lambda要使用外部的变量时，其内部不能修改外部变量的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 作用域问题</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 引用一个块外部的变量，在内部不能修改它的值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> c = <span class=\"number\">12</span>; </span><br><span class=\"line\">\t\ttest2(<span class=\"number\">56</span>, <span class=\"number\">45</span>, (a, b) -&gt; &#123;</span><br><span class=\"line\">\t\t\ta += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tb += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> d = a + b + c;</span><br><span class=\"line\">\t\t\tSystem.out.println(d);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, LambdaTestInterface2 lam2)</span> </span>&#123;</span><br><span class=\"line\">\t\tlam2.init(a, b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LambdaTestInterface2</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如何理解java 8中引入的Lambda表达式？匿名类，从这里着手看看，在此之前，接口对象，可用匿名类实例化。而Lambda可以理解为接口的另一种实例化的方法，但前提是这个接口只能有一个抽象方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * lambda和匿名类的对比</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类的写法，当参数使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> result1 = operation(<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"keyword\">new</span> MathOperate() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// lambda，同样当参数使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> result2 = operation(<span class=\"number\">8</span>, <span class=\"number\">8</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(result1);</span><br><span class=\"line\">\t\tSystem.out.println(result2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">operation</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, MathOperate mathOperate)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mathOperate.operate(a, b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperate</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operate</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-方法引用\"><a href=\"#2-方法引用\" class=\"headerlink\" title=\"2. 方法引用\"></a>2. 方法引用</h1><p>使用“::”进行方法引用，按引用的方法分三类：</p>\n<ul>\n<li>静态方法；</li>\n<li>构造方法；</li>\n<li>成员方法。</li>\n</ul>\n<p>引用静态方法，类名::方法名。方法参数和返回值需要和接口中的一致；<br>引用构造函数，类名::new。构造函数需要和接口中参数一致；<br>引用对象方法，对象.方法名。方法参数和返回值需要和接口中的一致，不能通过对象引用静态方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodJava8</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 方法引用</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// ::可以引用静态方法，对象的方法或构造函数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.静态方法引用，引用方法的形参和返回值，需和接口中的一致</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert = Integer::valueOf;</span><br><span class=\"line\">\t\tSystem.out.println(convert.convert(<span class=\"string\">\"888\"</span>));</span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类的方法实现</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert2 = <span class=\"keyword\">new</span> Convert&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">convert</span><span class=\"params\">(String t1)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(convert2.convert(<span class=\"string\">\"999\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 引用自定义类的静态方法</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert3 = MyConvert::convert;</span><br><span class=\"line\">\t\tSystem.out.println(convert3.convert(<span class=\"string\">\"101010\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.引用对象中的方法，静态方法不能通过对象引用</span></span><br><span class=\"line\">\t\tMyConvert myConvert = <span class=\"keyword\">new</span> MethodJava8.MyConvert();</span><br><span class=\"line\">\t\t<span class=\"comment\">//引用对象的成员方法</span></span><br><span class=\"line\">\t\tConvert&lt;String, Integer&gt; convert4 = myConvert::convert2;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Convert&lt;String, Integer&gt; convert4 = myConvert::convert; //错误，不能引用静态方法</span></span><br><span class=\"line\">\t\tSystem.out.println(convert4.convert(<span class=\"string\">\"111111\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 3.引用User的构造函数</span></span><br><span class=\"line\">\t\tUserFactory&lt;User&gt; userfactory = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\t\tUser user = userfactory.create(<span class=\"string\">\"Test2\"</span>, <span class=\"number\">22</span>, <span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(user.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 匿名类实现UserFactory</span></span><br><span class=\"line\">\t\tUserFactory&lt;User&gt; userfactory2 = <span class=\"keyword\">new</span> UserFactory&lt;User&gt;() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">create</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, String gendle)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(name, age, gendle);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(userfactory2.create(<span class=\"string\">\"Test1\"</span>, <span class=\"number\">11</span>, <span class=\"string\">\"female\"</span>).getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Convert</span>&lt;<span class=\"title\">T1</span>, <span class=\"title\">T2</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">T2 <span class=\"title\">convert</span><span class=\"params\">(T1 t1)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserFactory</span>&lt;<span class=\"title\">U</span> <span class=\"keyword\">extends</span> <span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">U <span class=\"title\">create</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, String gendle)</span></span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConvert</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">convert</span><span class=\"params\">(String t1)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">convert2</span><span class=\"params\">(String t1)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Integer.valueOf(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-默认方法\"><a href=\"#3-默认方法\" class=\"headerlink\" title=\"3. 默认方法\"></a>3. 默认方法</h1><p>在接口的方法前加default关键字，表示一个默认方法，加static表示默认静态方法。<br>有了默认方法，在需求变更的时候，不必因增加接口中的方法，而需要重新实现已经实现该接口的类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultMethod</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 默认方法</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tMyDefaultMethodTest.operate();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tMyDefaultMethodTest myDefaultMethodTest = <span class=\"keyword\">new</span> MyDefaultMethodTest() &#123;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmyDefaultMethodTest.init();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyDefaultMethodTest</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"It is init() in MyDefaultMethodTest\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//默认静态方法，不能通过对象访问</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">operate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"It is operate() in MyDefaultMethodTest\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Stream\"><a href=\"#4-Stream\" class=\"headerlink\" title=\"4. Stream\"></a>4. Stream</h1><p>Stream，类似把操作的对象看成一个数据流，对它操作后会返回被处理后的流，可以继续操作，比如排序，过滤，变换等等。</p>\n<ul>\n<li>数据流的生成<br>集合，数组，IO，产生器等。</li>\n<li>数据流操作<br>foreach，map，filter，limit，sorted，parallel等。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamJava8</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 创建Stream流</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; filtered1 = list.stream()</span><br><span class=\"line\">\t\t\t\t.filter(string -&gt; !string.isEmpty())</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 聚合操作</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// foreach</span></span><br><span class=\"line\">\t\tfiltered1.forEach(s -&gt; System.out.println(s));</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// map</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; mapNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; mapResult = mapNumbers.stream().map(a -&gt; a * a)</span><br><span class=\"line\">\t\t\t\t.distinct().collect(Collectors.toList());</span><br><span class=\"line\">\t\tmapResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// filter</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; filterNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; filterResult = filterNumbers.stream().filter(a -&gt; a &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tfilterResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// limit</span></span><br><span class=\"line\">\t\tList&lt;String&gt; limitStr = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; limitResult = limitStr.stream().limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tlimitResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// sorted</span></span><br><span class=\"line\">\t\tList&lt;Integer&gt; sortedNumbers = Arrays.asList(<span class=\"number\">11</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; sortedResult = sortedNumbers.stream()</span><br><span class=\"line\">\t\t\t\t.sorted((a, b) -&gt; a &lt; b ? <span class=\"number\">1</span> : a == b ? <span class=\"number\">0</span> : -<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\tsortedResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// parallel</span></span><br><span class=\"line\">\t\tList&lt;String&gt; parallelNumbers = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\tList&lt;String&gt; parallelResult = parallelNumbers.parallelStream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; str.equals(<span class=\"string\">\"a\"</span>)).collect(Collectors.toList());</span><br><span class=\"line\">\t\tparallelResult.forEach(System.out::println);</span><br><span class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collectors</span></span><br><span class=\"line\">\t\tList&lt;String&gt; collectorsStr = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回List</span></span><br><span class=\"line\">\t\tList&lt;String&gt; collectorResultList = collectorsStr.stream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; !str.isEmpty()).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"列表: \"</span> + collectorResultList);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回String</span></span><br><span class=\"line\">\t\tString collectorResultString = collectorsStr.parallelStream()</span><br><span class=\"line\">\t\t\t\t.filter(str -&gt; !str.isEmpty()).collect(Collectors.joining(<span class=\"string\">\"+\"</span>));</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"合并: \"</span> + collectorResultString);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>能力有限，先写到这，部分要点来自网络，仅作学习之用。</p>"}],"PostAsset":[{"_id":"source/_posts/linearLayout/width_0.png","post":"cjllstdb00003idfs0l42vt89","slug":"width_0.png","modified":1,"renderable":1},{"_id":"source/_posts/linearLayout/width_enough.png","post":"cjllstdb00003idfs0l42vt89","slug":"width_enough.png","modified":1,"renderable":1},{"_id":"source/_posts/linearLayout/width_less.png","post":"cjllstdb00003idfs0l42vt89","slug":"width_less.png","modified":1,"renderable":1},{"_id":"source/_posts/linearLayout/width_match.png","post":"cjllstdb00003idfs0l42vt89","slug":"width_match.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}